<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-06-23 Tue 21:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Odgovori na ispitna pitanja iz UOAR2</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Aleksandar Šmigić" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<style> div > .org-ol > li { margin-top: 3%; } </style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&amp;dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Odgovori na ispitna pitanja iz UOAR2</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org555eea0">1. Iskazna logika</a></li>
<li><a href="#org473c513">2. Minimizacija logičkih izraza</a></li>
<li><a href="#orgc80b155">3. Tranzistori i logička kola</a></li>
<li><a href="#org4e39f30">4. Kombinatorna kola</a>
<ul>
<li><a href="#org5e72611">4.1. Multipleksor i demultipleksor</a></li>
<li><a href="#org448086b">4.2. Koder i dekoder</a></li>
<li><a href="#org71ccdcf">4.3. Komparator</a></li>
<li><a href="#orge176bb8">4.4. Pomerač</a></li>
<li><a href="#orge82f964">4.5. Sabirači i oduzimači</a></li>
<li><a href="#org115ccc5">4.6. Implementacija ALU i kombinatornih memorija</a></li>
</ul>
</li>
<li><a href="#orge5836ae">5. Sekvencijalna kola</a>
<ul>
<li><a href="#orge5d2338">5.1. Reze i flip-flopovi</a></li>
<li><a href="#org6b0a4d2">5.2. Implementacija <code>RAM</code>-a</a></li>
<li><a href="#orgf38ec3e">5.3. Binarni brojač</a></li>
<li><a href="#orgcc61e04">5.4. Konačni automati i transduktori</a></li>
</ul>
</li>
<li><a href="#org3e07115">6. Arhitektura i organizacija</a></li>
<li><a href="#org5452d6c">7. Adresiranje</a></li>
<li><a href="#org33fa976">8. Assembler</a></li>
<li><a href="#org59dbce1">9. Procesor</a></li>
<li><a href="#org49175b8">10. Memorija</a></li>
<li><a href="#org7196f69">11. Cache</a></li>
<li><a href="#orge5ab0a6">12. Magistrale</a></li>
<li><a href="#orgf9eb8cc">13. Sistem prekida</a></li>
<li><a href="#orge6efa74">14. I/O</a></li>
<li><a href="#org2531953">15. Virtuelna memorija</a></li>
<li><a href="#org27e8d91">16. Moderni procesori</a></li>
<li><a href="#orgdab1616">17. Verilog</a></li>
</ul>
</div>
</div>

<div id="outline-container-org555eea0" class="outline-2">
<h2 id="org555eea0"><span class="section-number-2">1</span> Iskazna logika</h2>
<div class="outline-text-2" id="text-1">
<ol class="org-ol">
<li value="1">Napisati istinitosne tablice osnovnih logičkih veznika (NE, I, ILI)

<ul class="org-ul">
<li><p>
NE
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">A</td>
<td class="org-right">NE(A)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
<li><p>
I
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">A</td>
<td class="org-right">B</td>
<td class="org-right">I(A, B)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li><p>
ILI
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">A</td>
<td class="org-right">B</td>
<td class="org-right">ILI(A, B)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
</ul></li>

<li>Napisati istinitosne tablice izvedenih logičkih veznika (NI, NILI, EILI)

<ul class="org-ul">
<li><p>
NI (NAND)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">A</td>
<td class="org-right">B</td>
<td class="org-right">NI(A, B)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
<li><p>
NILI (NOR)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">A</td>
<td class="org-right">B</td>
<td class="org-right">NILI(A, B)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
<li><p>
EILI (XOR)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">A</td>
<td class="org-right">B</td>
<td class="org-right">EILI(A, B)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
</ul></li>

<li>Navesti bar jedan način na koji se EILI veznik može predstaviti pomoću osnovnih logičkih veznika (NE, I, ILI)

<ul class="org-ul">
<li>Preko KNF-a
(A ili ne(B)) i (ne(A) ili B)</li>
</ul></li>

<li><p>
Navesti osnovne zakone algebre logike
</p>

<p>
Algebra logike je uređena šestorka \((S, \cdot, +, \bar{}, 1, 0)\)
</p>
<ul class="org-ul">
<li>\(S\) - neprazan skup</li>
<li>\(\cdot, +\) - binarne operacije</li>
<li>\(\bar{}\) - unarna operacija</li>
<li><p>
\(1, 0\) - izdvojeni elementi skupa \(S\)
</p>

<p>
Osnovni zakoni:
</p>
<ol class="org-ol">
<li>Asocijativnost
<ul class="org-ul">
<li>\((x \cdot y) \cdot z = x \cdot (y \cdot z)\)</li>
<li>\((x + y) + z = x + (y + z)\)</li>
</ul></li>
<li>Neutral
<ul class="org-ul">
<li>\(x \cdot 1 = x\)</li>
<li>\(x + 0 = x\)</li>
</ul></li>
<li>Komplementarnost
<ul class="org-ul">
<li>\(x \cdot \bar{x} = 0\)</li>
<li>\(x + \bar{x} = 1\)</li>
</ul></li>
<li>Komutativnost
<ul class="org-ul">
<li>\(x \cdot y = y \cdot x\)</li>
<li>\(x + y = y + x\)</li>
</ul></li>
<li>Distributivnost
<ul class="org-ul">
<li>\(x \cdot (y + z) = x \cdot y + x \cdot z\)</li>
<li>\(x + (y \cdot z) = (x + y) \cdot (x + z)\)</li>
</ul></li>
</ol></li>
</ul></li>

<li><p>
Zbog čega se algebra logike koristi kao osnova savremenih računara?
</p>

<p>
Iz razloga što je mnogo jednostavnije, stabilnije i jeftinije napraviti fizički uređaj koji ime dva diskretna stanja nego više njih. Takođe, aritmetičke operacije nad binarnim brojevima je jednostavno opisati pomoću algebre logike i samim tim implementirati pomoću logičkih kola.
</p></li>

<li><p>
Šta znači da su dva logička izraza ekvivalentna?
</p>

<p>
Znači da su im vrednosti pri istim valuacijama promenljivih iste odnosno da za istu kombinaciju vrednosti &ldquo;ulaznih&rdquo; promenljivih daju isti &ldquo;izlaz&rdquo;
</p></li>

<li>Definisati pojmove elementarne konjunkcije i disjunktivne normalne forme (DNF). Šta je savršena elementarna konjunkcija, a šta savršena DNF?

<ul class="org-ul">
<li>Literal je logički izraz koji je ili logička promenljiva ili negacija logičke promenljive (eg. \(x, \bar{y}\))</li>
<li>Elementarna konjunkcija je logički izraz koji se sastoji iz konjunkcije literala (eg. \(x\bar{y}z\bar{p}\))
<ul class="org-ul">
<li>Savršena elementarna konjunkcija sadrži tačno jedan literal za svaku logičku promenljivu (eg. \(P = {x, y, z}, S = \bar{x} \cdot y \cdot z\))</li>
</ul></li>
<li>DNF je logički izraz koji se sastoji od disjunkcije elementarnih konjunkcija (eg. \(x\bar{y}z + \bar{x}yz + xyz)\)
<ul class="org-ul">
<li>Savršena DNF se sastoji od disjunkcije savršenih elementarnih konjunkcija</li>
</ul></li>
</ul></li>

<li>Definisati pojmove elementarne disjunkcije i konjunktivne normalne forme (KNF). Šta je savršena elementarna disjunkcija, a šta savršena KNF?

<ul class="org-ul">
<li>Literal je logički izraz koji je ili logička promenljiva ili negacija logičke promenljive (eg. \(x, \bar{y}\))</li>
<li>Elementarna disjunkcija je logički izraz koji se sastoji iz disjunkcije literala (eg. \(x + \bar{y} + z\bar{p}\))
<ul class="org-ul">
<li>Savršena elementarna disjunkcija sadrži tačno jedan literal za svaku logičku promenljivu (eg. \(P = {x, y, z}, \bar{x} + y + z\))</li>
</ul></li>
<li>KNF je logički izraz koji se sastoji od konjunkcije elementarnih disjunkcija (eg. \((x + \bar{y} + z) \cdot (\bar{x} + y + z) \cdot (x + y + z)\)
<ul class="org-ul">
<li>Savršena KNF se sastoji od konjunkcije savršenih elementarnih disjunkcija</li>
</ul></li>
</ul></li>

<li>Ukratko opisati postupak za svođenje logičkog izraza na DNF

<ol class="org-ol">
<li>Eleminisanje logičkih konstanti - primena veznika nad 0 i 1 sve dok se izraz ne svede na 0 ili 1 ili ostane bez konstanti</li>
<li>De Morganovi zakoni i dupla negacija</li>
<li>Distributivnost \(\cdot\) prema \(+\) - nakon ovog koraka dobijamo DNF
<ul class="org-ul">
<li>Za svođenje na KNF važe prethodna dva koraka, dok je treći distributivnost \(+\) prema \(\cdot\)</li>
</ul></li>
<li>Idempotentnost, neutral, apsorpcija - primenom ovih (i drugih zakona) moguće je dodatno minimizovati DNF</li>
</ol></li>

<li><p>
Šta je logička funkcija i koliko ima funkcija reda \(n\)?
</p>

<p>
Logička funkcija je svako preslikavanje \(f: {0, 1}^{n} \rightarrow {0, 1}\) koja <b>logičke vrednosti</b> \((x_{1}, x_{2}, ..., x_{n})\) slika u <b>logičku vrednost</b> \(y \in {0, 1}\).
Kardinalnost domena logičkih funkcija reda \(n\) je \(2^{n}\), dok je kodomena \(2\), dakle, pošto se svaka funkcija iz domena može slikati u dve vrednosti u kodomenu, postoji \(2^{2^{n}}\) funkcija reda \(n\)
</p></li>

<li><p>
Šta je potpun sistem veznika? Navesti bar tri primera potpunih sistema logičkih veznika
</p>

<p>
Potpun sistem veznika predstavlja skup veznika pomoću kojeg je moguće predsaviti svaku logičku funkciju.
Primeri:
</p>
<ol class="org-ol">
<li>I, ILI, NE</li>
<li>I, NE</li>
<li>ILI, NE</li>
<li>NI (Šeferov veznik: \(\uparrow\))</li>
<li>NILI (Pirsov/Lukašijevičev veznik: \(\downarrow\))</li>
</ol></li>

<li>Izraziti NE, I i ILI veznik pomoću NI veznika

<ul class="org-ul">
<li>NE(x) = NI(x, x)</li>
<li>I(a, b) = NE(NI(a, b)) = NI(NI(a, b), NI(a, b))</li>
<li>ILI(a, b) = NE(I(NE(a), NE(b))) = &#x2026;</li>
</ul></li>

<li><p>
Ukratko objasniti kako se proizvoljna logička funkcija može izraziti u obliku izraza u savršenoj DNF
</p>

<p>
Čitajući tablicu logičke funkcije, ako je izlaz za neku valuaciju 1, onda na našu savršenu DNF formulu dodajemo novi konjunkt koji se sastoji iz konjunkcije literala koji za tu valuaciju daju vrednost 1.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org473c513" class="outline-2">
<h2 id="org473c513"><span class="section-number-2">2</span> Minimizacija logičkih izraza</h2>
<div class="outline-text-2" id="text-2">
<ol class="org-ol">
<li value="14"><p>
Šta je minimizacija logičkih izraza i zbog čega nam je značajna?
</p>

<p>
Minimizovati logički izraz znači pronaći logički ekvivalentan izraz koji sadrži najmanji mogući broj veznika.
</p>

<p>
Najčešće nam koristi pri dizajnu logičkih kola kako bismo smanjili cenu proizvodnje, ali suštinski može da služi za rešavanje mnogo šire grupe problema koji se mogu mapirati u SAT problem.
</p></li>

<li><p>
Na primeru objasniti metod algebarskih transformacija za minimizaciju logičkih izraza.
</p>

<p>
Koristimo dva pravila:
</p>
<ol class="org-ol">
<li>Grupisanje:
\[
       K_{1} = x \cdot K' \\
       K_{2} = \bar{x} \cdot K' \\
       \downarrow \\
       K = K'(x + \bar{x}) = K' \\
       \]</li>

<li>Udvajanje:
<ul class="org-ul">
<li>U slučaju da imamo konjunkte \(K_{1}, K_{2}\) nad kojima bismo mogli da primenimo <i>grupisanje</i> sa \(K\), onda dupliramo \(K\) da bismo mogli da grupišemo sa oba</li>
</ul></li>
</ol>

<p>
Eg. \(F(x, y, z) = x\bar{y}z + \bar{x}\bar{y}z + x\bar{y}\bar{z}\)
Možemo grupisati prvi i drugi i prvi i treći, tako da ćemo primeniti prvo <i>udvajanje</i> pa tek onda grupisanje
\(F(x, y, z) = x\bar{y}z + \bar{x}\bar{y}z + x\bar{y}z + x\bar{y}\bar{z}\)
\(F(x, y, z) = \bar{y}z(x + \bar{x}) + x\bar{y}(z + \bar{z})\)
\(F(x, y, z) = \bar{y}z(x + \bar{x}) + x\bar{y}(z + \bar{z})\)
\(F(x, y, z) = \bar{y}z + x\bar{y}\)
</p></li>

<li><p>
Objasniti način upotrebe Karnoovih mapa za minimizaciju logičkih izraza. Primer.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Karnoove mape predstavljaju grafički metod za minimizaciju logičkih izraza koji funkcioniše po principu grupisanja. Nakon što nacrtamo tabelu gde se susendna polja (susedstvo se gleda kao da je tabela zapravo površina torusa) razlikuju za jednu vrednost (Grejov kod) popunimo mesta koja u tabeli daju \(1\) kao rezultat. Minimizujemo tako što prvo pokušamo da obuhvatimo sve \(1\) u pravougaonik od \(16\) elemenata, zatim redom \(8\), \(4\), \(2\), \(1\). Posmatramo promenljive u okviru jednog pravougaonika koje se nisu promenile i njih stavljamo u finalnu minimizovanu DNF formulu.
</p></li>

<li><p>
Objasniti metodu Kvin-Meklaskog za minimizaciju logičkih izraza. Primer.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>
<p>
Metoda Kvin-Meklaskog je metoda minimiacije logičkih izraza koja je pogodna za implementaciju na računaru.
</p>

<ol class="org-ol">
<li>Na ulazu dobijamo funkciju u SDNF. Sortiramo rastuće savršene konjunkcije po broju neinvertovanih literala i izdelimo ih u klase, gde $i$-ta klasa sadrži SK koji imaju \(i\) neinvertovanih literala.</li>

<li>Vršimo grupisanje elemenata iz $i$-te sa elementima iz $i + 1$-ve klase, i rezultat čuvamo za sledeću iteraciju. Grupisanje je moguće ako se elementi koji se porede razlikuju samo na jednom mestu. Ovo radimo sve dok je moguće grupisati.</li>

<li>Formiramo tabelu prostih implikanata (vidi primer). Identifikujemo <i>bitne proste implikante</i>.</li>
</ol></li>

<li><p>
Kako se upotrebljavaju Karnoove mape u prisustvu nebitnih vrednosti? Primer.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Kada imamo nebitne (<i>don&rsquo;t care</i>) vrednost, njih možemo da tretiramo onako kako nama odgovara, odnosno ako nam omogućavaju da zaokružimo veću površinu tretiramo ih kao \(1\), u suprotnom nema potrebe da ih zaokružimo.
</p></li>

<li><p>
Kako se metod Kvin-Meklaskog koristi u prisustvu nebitnih vrednosti? Primer.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
U prvoj fazi algoritma se nebitne vrednosti tretiraju kao \(1\), odnosno učestvuju u grupisanju.
</p>

<p>
U drugoj fazi algoritma se nebitne vrednosti tretiraju kao \(0\), tj. ne navode se u tabeli prostih implikanata.
</p></li>

<li><p>
Šta je Petrikov metod i koja je njegova uloga u okviru metode Kvin-Mekalskog? Primer.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>
<p>
Petrikov metod je metod koji se koristi za pronalaženje najmanjeg podskupa preostalih prostih implikanata u slučaju da neka kolona ostane &ldquo;nepokrivena&rdquo; u metodi Kvin-Mekalskog.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orgc80b155" class="outline-2">
<h2 id="orgc80b155"><span class="section-number-2">3</span> Tranzistori i logička kola</h2>
<div class="outline-text-2" id="text-3">
<ol class="org-ol">
<li value="21"><p>
Elementarna logička kola (gejtovi) i njihove šematske oznake.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<ul class="org-ul">
<li>Buffer</li>
<li>3-state buffer</li>
<li>NOT</li>
<li>AND</li>
<li>OR</li>
<li>NAND</li>
<li>NOR</li>
<li>XOR</li>
<li>NXOR</li>
</ul></li>

<li><p>
Nacrtati simbol i objasniti funkciju NMOS tranzistora.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
NMOS tranzistor ima 3 ulaza:
</p>
<ol class="org-ol">
<li>Source - povezan sa <b>negativan</b> napon</li>
<li>Drain - povezan na <b>pozitivan</b> napon</li>
<li>Gate - odredjuje da li će struja proticati
<ul class="org-ul">
<li>Ako je napon u zoni logičke nule onda je izlaz 0</li>
<li>Ako je napon u zoni logičke jedinice onda je izlaz 1</li>
</ul></li>
</ol>

<p>
NMOS tranzistor ima ulogu u donjoj mreži (<i>pulldown network</i>) prekidača da poveže masu (<i>ground</i>) sa izlazom da bi u slučaju <b>niske</b> voltaže na izlazu bila <b>0</b>
</p></li>

<li><p>
Nacrtati simbol i objasniti funkciju PMOS tranzistora.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
PMOS tranzistor ima 3 ulaza:
</p>
<ol class="org-ol">
<li>Source - povezan sa <b>pozitivan</b> napon</li>
<li>Drain - povezan na <b>negativan</b> napon</li>
<li>Gate - odredjuje da li će struja proticati
<ul class="org-ul">
<li>Ako je napon u zoni logičke nule onda je izlaz 1</li>
<li>Ako je napon u zoni logičke jedinice onda je izlaz 0</li>
</ul></li>
</ol>

<p>
PMOS tranzistor ima ulogu u gornjoj mreži (<i>pullup network</i>) prekidača da poveže napajanje (<i>supply</i>) sa izlazom da bi u slučaju <b>visoke</b> voltaže na izlazu bila <b>1</b>
</p></li>

<li><p>
Implementacija NE kola u CMOS-u
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<ul class="org-ul">
<li>Ako je ulaz 0 samo iz PMOS-a tranzistora će izlaziti struja koja predstavlja 1</li>
<li>Ako je ulaz 1 samo iz NMOS-a tranzistora će izlaziti struja koja predstavlja 0</li>
<li>Dakle, biće <i>upaljen</i> samo tranzistor koji je potreban, čime se postiže ušteda u potrošnji i smanjuje grejanje komponenti.</li>
</ul></li>

<li><p>
Implementacija NI i I kola u CMOS-u
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Donja mreža se implementira rednim povezivanjem dva NMOS tranzistora čime se postiže da se 0 dobije samo kada su oba ulaza 1
</p>

<p>
Gornja mreža se implementira paralelnim povezivanjem dva PMOS tranzistora čime se postiže da se 1 dobija samo kada je barem jedan od ulaza 0 (čime se takođe osigurava da pri ulazu 1 1 pušta samo donja mreža &ldquo;da radi&rdquo;)
</p>

<p>
I se dobija tako što se na NI nadoveže NE
</p></li>

<li><p>
Implementacija NILI i ILI kola u CMOS-u
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
NILI se implementira po istom principu kao NI, s tim što su ovde NMOS tranzistori povezani paralelno, dok su PMOS povezani redno.
</p>

<p>
Gornja mreža se implementira rednim povezivanjem dva PMOS tranzistora čime se postiže da se 1 dobije samo kada su oba ulaza 0
</p>

<p>
Donja mreža se implementira paralelnim povezivanjem dva NMOS tranzistora čime se postiže da se 0 dobija samo kada je barem jedan od ulaza 1 (čime se takođe osigurava da pri ulazu 0 0 pušta samo gornja mreža &ldquo;da radi&rdquo;)
</p>

<p>
ILI se dobija tako što se na NILI nadoveže NE
</p></li>

<li><p>
Implementacija EILI kola u CMOS-u
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Donja mreža se implementira pomoću 4 redno-paralelna NMOS tranzistora čiji ulazi su \(X\) i \(Y\) s leve i \(\bar{X}\) i \(\bar{Y}\) s desne strane čime se 0 dobija samo akko su \(X\) i \(Y\) isti
</p>

<p>
Gornja mreža se implementira pomoću 4 redno-paralelna PMOS tranzistora čiji ulazi su \(X\) i \(\bar{Y}\) s leve i \(\bar{X}\) i \(Y\) s desne strane čime se 1 dobijamo samo akko su \(X\) i \(Y\) različiti
</p></li>

<li><p>
Propusni tranzistori i prenosne kapije. Funkcija i uloga.
</p>

<p>
Propusne tranzistore koristimo u slučaju da nam je potrebno uslovno propuštanje nekog signala. Ako koristimo samo NMOS tranzistor imaćemo problem sa propuštanjem signala 1 jer neće postojati velika razliku u naponu između <i>source</i>-a i <i>gate</i>-a. Analogno za samo PMOS i signal 0.
</p>

<p>
Da bismo to rešili, koristimo prenosne kapije koje su spoj ova dva propusna tranzistora. Često se koriste i za realizaciju bafera sa 3 stanja.
</p></li>

<li><p>
Šta je bafer sa tri stanja i čemu služi?
</p>

<p>
Bafer sa 3 stanja je logičko kolo koje služi za pojačavanje stanja i uslovno/kontrolno propuštanje signala.
</p></li>

<li><p>
Implementacija bafera sa tri stanja u CMOS-u.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Implementacija zavisi od toga šta nam je potrebno, i koje signale imamo na raspolaganju. U slučaju da nam nije potrebno pojačavanje signala neće nam trebati dvostruki inverter. Povezujemo ulazni signal, kontrolni signal i njegovu negaciju sa prenosnom kapijom čime i implementiramo bafer sa tri stanja.
</p></li>

<li><p>
Šta je vrednost visoke impendanse i koja je njena uloga u logičkim kolima?
</p>

<p>
Vrednost visoke impendanse odgovara tipu NULL u nekim višim programskim jezicima, odnosno predstavlja odsustvo vrednosti. Označavamo je sa <b>Z</b> i koristimo je na primer u slučaju da imamo dva kola koja se povezuju na isti ulaz, kako ne bismo imali vrednosti u konfliktu, jedna od njih ima vrednost visoke impendanse.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org4e39f30" class="outline-2">
<h2 id="org4e39f30"><span class="section-number-2">4</span> Kombinatorna kola</h2>
<div class="outline-text-2" id="text-4">
<ol class="org-ol">
<li><p>
Šta je kombinatorno kolo?
</p>

<p>
Kombinatorno kolo je logičko kolo čije vrednosti na izlazima se mogu sračunati u bilo kom trenutku u zavisnosti od ulaznih vrednosti odnosno prethodne ulazne vrednosti ne utiču na novu izlaznu vrednost.
</p></li>

<li><p>
Navesti najvažnije vrste osnovnih kombinatornih kola.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<ul class="org-ul">
<li>Multipleksor (Mux)</li>
<li>Demultipleksor (DeMux)</li>
</ul></li>
</ol>
</div>

<div id="outline-container-org5e72611" class="outline-3">
<h3 id="org5e72611"><span class="section-number-3">4.1</span> Multipleksor i demultipleksor</h3>
<div class="outline-text-3" id="text-4-1">
<ol class="org-ol">
<li><p>
Šta je multipleksor i koja mu je osnovna funkcija? Predstaviti grafičkim simbolom i tablicom multipleksor 4-1.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Multipleksor \(2^{k}-1\) je kombinatorno kolo koje omogućava selekciju nekog od \(k\) ulaza pomoću selekcionih bitova, čime faktički igra istu ulogu kao `if else` konstrukt u višim programskim jezicima.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">S</td>
<td class="org-left">I</td>
</tr>

<tr>
<td class="org-right">00</td>
<td class="org-left">\(U_{0}\)</td>
</tr>

<tr>
<td class="org-right">01</td>
<td class="org-left">\(U_{1}\)</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">\(U_{2}\)</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">\(U_{3}\)</td>
</tr>
</tbody>
</table></li>

<li><p>
Nacrtati logičko kolo implementacije multipleksora 4-1.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<ul class="org-ul">
<li>Možemo implementirati direktno</li>

<li>Možemo implementirati pomoću multipleksora 2-1</li>
</ul></li>

<li><p>
Kako se multipleksor upotrebljava za implementaciju logičkih funkcija?
</p>

<p>
Fiksiranjem jedne ili više vrednosti, jednu &ldquo;veliku&rdquo; funkciju dekomponujemo na dve ili više manjih koje biramo pomoću multipleksora.
</p></li>

<li><p>
Šta je demultipleksor i koja je njegova osnovna funkcija? Predstaviti grafičkim simbolom i tablicom demultipleksor 1-4.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Demultipleksor je kombinatorno kolo koje igra obrnutu ulogu u odnosu na multipleksor, odnosno ima \(1\) ulaz koji preusmerava na \(2^{k}\) izlaza u zavisnosti od vrednosti selekcionih bitova.
</p>

<p>
U nepopunjenim ćelijama tabele može biti 0 ili <b>Z</b> u zavisnosti od implementacije.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">S</td>
<td class="org-left">\(I_{0}\)</td>
<td class="org-left">\(I_{1}\)</td>
<td class="org-left">\(I_{2}\)</td>
<td class="org-left">\(I_{3}\)</td>
</tr>

<tr>
<td class="org-right">00</td>
<td class="org-left">\(U_{0}\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">01</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(U_{0}\)</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(U_{0}\)</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\(U_{0}\)</td>
</tr>
</tbody>
</table></li>

<li><p>
Nacrtati logičko kolo implementacije demultipleksora 1-4.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<ul class="org-ul">
<li>Možemo implementirati direktno</li>

<li>Možemo implementirati pomoću demultipleksora 1-2</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org448086b" class="outline-3">
<h3 id="org448086b"><span class="section-number-3">4.2</span> Koder i dekoder</h3>
<div class="outline-text-3" id="text-4-2">
<ol class="org-ol">
<li value="39"><p>
Šta je dekoder i koja je njegova osnovna funkcija? Predstaviti grafičkim simbolom i tablicom dekoder 2-4.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Dekoder je kombinarno kolo koje na osnovu vrednosti binarnog broja aktivira odgovarajući signal na izlazu. Najčešće se koristi pri dekodiranju mašinskih instrukcija.
</p>

<p>
Eg. Ako pretpostavimo da imamo 16 registara, u samoj instrukciji možemo kodirati koje registre koristimo samo preko 4 bita. Dekoder služi za &ldquo;prevođenje&rdquo; koje registre želimo da učestvuju.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">S</td>
<td class="org-right">\(I_{0}\)</td>
<td class="org-right">\(I_{1}\)</td>
<td class="org-right">\(I_{2}\)</td>
<td class="org-right">\(I_{3}\)</td>
</tr>

<tr>
<td class="org-right">00</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">01</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>

<li><p>
Nacrtati logičko kolo implementacije dekodera 2-4.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Praktično isto kao i demultipleksor 1-4 (direktna implementacija) s tim što je ovde binarna konjunkcija i nemamo ulaz već samo kontrolne bitove.
</p></li>

<li><p>
Šta je koder i gde se obično koristi? Šta je koder sa prioritetom?
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Koder je kombinatorno kolo koje \(2^{k}\) ulaza mapira u $k$-bitni broj (pod pretpostavkom da je najviše jedan ulaz 1). Takođe imamo i kontrolni izlaz koji nas obaveštava u slučaju da nijedan ulaz nije 1.
</p>

<p>
Obično se koristi u keš memorijama za određivanje indeksa registra koji sadrži određenu vrednost (prisutnost vrednosti se proverava komparatorima).
</p>

<p>
Običan komparator ne može da handle-uje slučaj kada je više od jednog ulaza 1. Iz tog razloga svakom od ulaza se pridodaje težina, što omogućava da na izlazu bude ulaz sa najvišim prioritetom.
</p></li>

<li><p>
Nacrtati logičko kolo implementacije kodera 4-2.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Implementacija ima smisla kad se pogleda tabela (namerno su naopačke indeksi)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">\(U_{3}\)</td>
<td class="org-right">\(U_{2}\)</td>
<td class="org-right">\(U_{1}\)</td>
<td class="org-right">\(U_{0}\)</td>
<td class="org-right">\(I_{1}\)</td>
<td class="org-right">\(I_{0}\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>

<li><p>
Nacrtati logičko kolo implementacije kodera 4-2 sa prioritetom.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Ne kapiram crtež moraću u nekoj knjizi to da vidim verovatno
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org71ccdcf" class="outline-3">
<h3 id="org71ccdcf"><span class="section-number-3">4.3</span> Komparator</h3>
<div class="outline-text-3" id="text-4-3">
<ol class="org-ol">
<li value="44"><p>
Šta je komparator? Navesti osnovne vrste komparatora.
</p>

<p>
Komparator je kombinatorno kolo koje služi za upoređivanje dva podatka.
</p>

<p>
Vrste:
</p>
<ul class="org-ul">
<li>Komparatori za jednakost</li>
<li>Komparatori za potpuno poređenje</li>
</ul></li>

<li><p>
Nacrtati logičko kolo 4-bitnog komparatora (za poređenje na jednakost)
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Bitovi se redom porede tako što se <b>XOR</b>-uju i na kraju povežu sa <b>NILI</b> gejtom koje će dati \(1\) ako su svi ulazi \(0\) i \(0\) u suprotnom
</p></li>

<li><p>
Nacrtati logičko kolo 4-bitnog komparatora za potpuno poređenje
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Koristimo 4-bitni oduzimač čiji rezultat šaljemo na NILI koje nam govori da li su ulazi jednaki i <i>carry bit</i> koji nam govori da li je \(x\) manji od \(y\), u suprotnom kad su oba \(0\), \(x\) je veći od \(y\)
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orge176bb8" class="outline-3">
<h3 id="orge176bb8"><span class="section-number-3">4.4</span> Pomerač</h3>
<div class="outline-text-3" id="text-4-4">
<ol class="org-ol">
<li value="47"><p>
Nacrtati logičko kolo 8-bitnog pomerača (ulevo)
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Pošto je 8-bitni pomerač, maksimalno je moguće pomeriti ga 7 puta.
</p>

<p>
Ideja je da se pomoću 8-bitnih 2-1 multipleksora u zavisnosti od kontrolnih bitova prvo proba da se pomeri za 4 pa za 2 pa za 1, čijim kombinacijama je moguće dobiti vrednosti pomeranja između 0 i 7. Pomeranje se vrši tako što se u multipleksorima ručno poveže ulaz pomeren za \(2^{i}, i = 0,1,2\) bitova.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orge82f964" class="outline-3">
<h3 id="orge82f964"><span class="section-number-3">4.5</span> Sabirači i oduzimači</h3>
<div class="outline-text-3" id="text-4-5">
<ol class="org-ol">
<li value="46"><p>
Nacrtati istinitosnu tablicu i logičko kolo binarnog polusabirača
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">\(x\)</td>
<td class="org-right">\(y\)</td>
<td class="org-right">\(S\)</td>
<td class="org-right">\(C\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Iz čega se vidi da je \(S\) zapravo <b>XOR</b> od \(x\) i \(y\), a \(C\) <b>AND</b>.
</p></li>

<li><p>
Nacrtati istinitosnu tablicu i logičko kolo binarnog sabirača
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">\(x\)</td>
<td class="org-right">\(y\)</td>
<td class="org-right">\(pc\)</td>
<td class="org-right">\(S\)</td>
<td class="org-right">\(C\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table>

<p>
Možemo implementirati ili preko dva polusabirača ili direktno. Preko dva polusabirača je lakše.
</p></li>

<li><p>
Višebitni talasasti sabirač. Kašnjenje.
</p>

<p>
Ulančavanjem manjih sabirača koji zavise od svog <i>prethodnika</i> kako bismo dobili sabirač za veći broj bitova dolazimo u situaciju da kašnjenje raste linearno u odnosu na broj bitova. Talasasti sabirač znači da se <i>talasasto</i> računa zbir počevši od sabirača zaduženog za najniže bitove ka višim.
</p></li>

<li><p>
Nacrtati istinitosnu tablicu i logičko kolo binarnog poluoduzimača
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">\(x\)</td>
<td class="org-right">\(y\)</td>
<td class="org-right">\(S\)</td>
<td class="org-right">\(C\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>

<li><p>
Nacrtati istinitosnu tablicu i logičko kolo binarnog oduzimača
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">\(x\)</td>
<td class="org-right">\(y\)</td>
<td class="org-right">\(pc\)</td>
<td class="org-right">\(S\)</td>
<td class="org-right">\(C\)</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>

<li><p>
Višebitni talasasti oduzimač. Kašnjenje.
</p>

<p>
Ulančavanjem manjih oduzimača koji zavise od svog <i>prethodnika</i> kako bismo dobili oduzimač za veći broj bitova dolazimo u situaciju da kašnjenje raste linearno u odnosu na broj bitova. Talasasti oduzimač znači da se <i>talasasto</i> računa razlika počevši od sabirača zaduženog za najniže bitove ka višim.
</p></li>

<li><p>
Objasniti ukratko princip rada sabirača sa računanjem prenosa unapred.
</p>

<p>
CLA sabirači problem računanja zbira dva broja rade tako što efikasno pretprocesiraju u \(O(logN)\) vremenu, \(N\) - broj bitova, da li će biti prenosa na individualnom bitu i samim tim, sabiranje je moguće izvršiti paralelno nad svim bitovima čime je ukupna vremenska složenost sabiranja svedena na \(O(logN)\) za razliku od \(O(N)\) kod talasastog sabirača.
</p></li>

<li><p>
Šta kod sabirača sa računanjem prenosa unapred označavaju vrednosti \(P_{i}\) i \(G_{i}\) i po kojim se formulama računaju?
</p>

<p>
Koristeći činjenicu da prenos na $i$-tom bitu zavisi od toga da li $i$-ti bitovi generišu prenos ili prenose prethodni prenos, dobijamo formulu:
</p>

<p>
\[C_{0} = x_{0}y_{0} + x_{0}pc + y_{0}pc = x_{0}y_{0} + (x_{0} + y_{0})pc\]
što možemo dodatno svesti na
\[C_{0} = x_{0}y_{0} + (x_{0} \oplus y_{0})pc\]
jer ako su \(x\) i \(y\) jednaki \(1\) svakako će zbog prethodne disjunkcije biti validan izraz
</p>

<ul class="org-ul">
<li>\(G_{i}\) = x<sub>i</sub>y<sub>i</sub>$ - govori nam da li $i$-ti bit <b>generiše</b> prenos</li>
<li>\(P_{i}\) = x<sub>i</sub> &oplus; y<sub>i</sub>$ - govori nam da li $i$-ti bit <b>propagira</b> prethodni prenos</li>
</ul>

<p>
Finalno, imamo /rekurentnu jednačinu:
\[
    C_{i} = G_{i} + P_{i}C_{i - 1} \\
    C_{0} = G_{0} + P_{0}pc
    \]
</p></li>

<li><p>
Navesti formule po kojima CLA (<i>Carry Look Ahead</i>) jedinica računa prenose \(C_{i}\) kao i grupne \(P\) i \(G\) vrednosti.
</p>

<p>
\[
    C_{i} = G_{i} + P_{i}C_{i - 1} \\
    C_{0} = G_{0} + P_{0}pc \\
    \]
\[ G_{G} = \sum_{i = 0}^{K}G_{i}\prod_{j = i + 1}^{K}P_{j}\] \(K\) - broj bitova
\[ P_{G} = \sum_{i = 0}^{K}P_{i}\]
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org115ccc5" class="outline-3">
<h3 id="org115ccc5"><span class="section-number-3">4.6</span> Implementacija ALU i kombinatornih memorija</h3>
<div class="outline-text-3" id="text-4-6">
<ol class="org-ol">
<li value="57"><p>
Navesti primer implementacije ALU jedinice.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Nacrtaj kolo koje prima dva 8-bitna ulaza i 3-bitni \(op\) ulaz koji specificira koju operaciju treba izvrsiti. Stavi bilo kojih 8 operacija i povezi rezultate sa <i>mux</i>-om koji za selekcione bitove uzima \(op\).
</p></li>

<li><p>
Šta je programibilni niz logičkih elemenata (PLA)? Navesti primer
</p>

<p>
Programibilni niz logičkih elemenata je programibilni logički uređaj (<b>PLD</b>) koje ima programibilne AND zatim i OR gejtove.
</p>

<p>
Koristimo ih u slučaju da imamo fiksan skup &ldquo;retkih&rdquo;\/&ldquo;raštrkanih&rdquo; (eng. <i>sparse</i>) logičkih funkcija i želimo jednostavno i jeftino kolo koje će njih računati.
</p>

<p>
Primer procesa pravljenja PLA-a:
</p>
<ol class="org-ol">
<li>Funkcije koje želimo da računamo u PLA-u predstavimo u SDNF
<ul class="org-ul">
<li>neka su te funkcije u SDNF:
<ol class="org-ol">
<li>\(F_{1} = x\bar{y}\bar{z} + x\bar{y}z + xyz\)</li>
<li>\(F_{2} = \bar{x}yz + x\bar{y}z + xyz\)</li>
</ol></li>
</ul></li>
<li>Minimizujemo ih
<ul class="org-ul">
<li>dobijamo:
<ol class="org-ol">
<li>\(F_{1} = x\bar{y} + xz\)</li>
<li>\(F_{2} = yz + xz\)</li>
</ol></li>
</ul></li>

<li>Koliko imamo promeljivih toliko će nam <i>input buffer</i>-a trebati (<i>input buffer</i> nam daje njegov ulazni signal i njegovu negaciju)</li>

<li>Programibilno povezujemo AND gejtove sa izlazima <i>input buffer</i>-a u zavisnosti od konjunkta prisutnih u funkcijama
<ul class="org-ul">
<li>Imaćemo 3 <b>različita</b> konjunkta (\(x\bar{y}, xz, yz\)), dakle trebaće nam 3 AND gejta</li>
</ul></li>
<li>Programibilno povezujemo ILI gejtove sa AND gejtovima tako da dobijemo željene funkcije</li>
</ol></li>

<li><p>
Kako se pomoću kombinatornih mreža implementira neizmenjiva memorija (ROM)? Primer tablice i odgovarajuće implementacije.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Na ulazu se dobija adresa koja se potom prosleđuje ka dekoderu koji aktivira odgovarajuće izlaze na koje su povezani ulazi disjunkcija. U zavisnosti od povezanosti izlaza dekodera i ulaza disjunkcija određujemo koje podatke ćemo čitati iz ROM memorije.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">adr</td>
<td class="org-right">out</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-right">0101</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">1010</td>
</tr>

<tr>
<td class="org-right">01</td>
<td class="org-right">1100</td>
</tr>

<tr>
<td class="org-right">00</td>
<td class="org-right">0011</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orge5836ae" class="outline-2">
<h2 id="orge5836ae"><span class="section-number-2">5</span> Sekvencijalna kola</h2>
<div class="outline-text-2" id="text-5">
<ol class="org-ol">
<li value="60"><p>
Šta je sekvencijalno kolo? Po čemu se sekvencijalna kola razlikuju od kombinatornih kola?
</p>

<p>
Sekvencijalno kolo je logičko kolo koje daje izlaz na osnovu trenutnog ulaza i <b>prethodnih izlaza</b>.
</p>

<p>
Za razliku od sekvencijalnih, kombinatorna kola nemaju interno stanje koje se čuva u memoriji, stoga za isti ulaz uvek daju isti izlaz, što nije slučaj sa sekvencijalnim kolima.
</p></li>

<li><p>
Nacrtati konceptualni dijagram sekvencijalnog kola i objasniti osnovni princip rada.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<ul class="org-ul">
<li>\(G\) je kombinatorno kolo koje po principu povratne sprege održava stanje \(S\) (\(G\) se može posmatrati kao vektorska funkcija \(G: X \times S \rightarrow S\), za \(X\) skup svih ulaza i \(S\) skup svih stanja)
<ul class="org-ul">
<li>\(S\) se neće promeniti sve dok se $X ne promeni</li>
</ul></li>
<li>\(F\) je kombinatorno kolo koje transformiše stanje \(S\) u izlaz \(Y\) (\(F\) se može posmatrati kao vektorska funkcija \(F: S \rightarrow Y\) za \(X\) skup svih ulaza i \(S\) skup svih stanja)</li>
</ul></li>

<li>Šta je nestabilnost sekvencijalnog kola, a šta nedeterminističnost? Šta je metastabilnost?

<ul class="org-ul">
<li>Nestabilnost sekvencijalnog kola je pojava oscilovanja kola između različitih stanja</li>
<li>Nederminističnost sekvencijalnog kola je pojava odlaženja u neko &ldquo;nasumično&rdquo; stabilno stanje u zavisnosti od fizičkih faktora</li>
<li>Metastabilnost sekvencijalnog kola je pojava stabilizacije u nekom nevalidnom međustanju</li>
</ul></li>

<li><p>
Šta je funkcija (tablica) prelaska sekvencijalnog kola? Navesti primer.
</p>

<p>
To je vektorska logička funkcija koja deterministički definiše prelaz sa jednog stabilnog stanja u drugo stabilno stanje na osnovu prethodnog stanja i novog ulaza.
</p>

<p>
Funkcija prelaska za SR reze:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">S</td>
<td class="org-right">R</td>
<td class="org-left">Q</td>
<td class="org-right">Q<sup>next</sup></td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">-</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">-</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">-</td>
<td class="org-right">?</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><code>-</code> označava bilo koju vrednost</li>
<li><code>?</code> označava nedefinisanu vrednost</li>
</ul></li>

<li><p>
Objasniti ulogu časovnika. Na koji način časovnik omogućava sinhronizaciju sekvencijalnih kola?
</p>

<p>
Časovnik istom frekvencijom izbacuje naizmenično signale 0 i 1 što se koristi za sinhronizaciju sekvencijalnih kola. Postavljanjem frekvencije časovnika na dovoljnu tako da najsporije sekvencijalno kolo uspe da se dovede u stabilno stanje, omogućava da se vreme posmatra diskretno, što olakšava rezonovanje o sekvencijalnim kolima i omogućava jednostavnu sinhronizaciju. Svako kolo povezano na časovnik prima njegov signal, i svoje promene vrši isključivo kad signal časovnika to dozvoli.
</p></li>

<li><p>
Objasniti razliku između sinhronih i asinhronih sekvencijalnih kola.
</p>

<p>
Sinhrona sekvencijalna kola zavise od zajedničkog signala odnosno časovnika, koji svima diktira kada je moguće izvršiti promene stanja, dok asinhrona moraju eksplicitno da naprave komplikovane međusobne veze kako bi uskladile kada je dozvoljeno kojem kolu da izvrši promene stanja.
</p></li>

<li>Elementi ciklusa časovnika. Tipovi časovnika. Frekvencija časovnika.
<ul class="org-ul">
<li>Elementi ciklusa časovnika:
<ul class="org-ul">
<li><b>Pozitivan</b> deo ciklusa = vreme trajanja \(1\)</li>
<li><b>Negativan</b> deo ciklusa = vreme trajanja \(0\)</li>
</ul></li>
<li>Tipovi časovnika:
<ul class="org-ul">
<li>Simetrični = pozitivan deo ciklusa traje isto koliko i negativan</li>
<li>Asimetrični = različito traju pozitivan i negativan deo ciklusa</li>
</ul></li>
<li>Frekvencija časovnika = broj ciklusa u jednoj sekundi</li>
</ul></li>
</ol>
</div>

<div id="outline-container-orge5d2338" class="outline-3">
<h3 id="orge5d2338"><span class="section-number-3">5.1</span> Reze i flip-flopovi</h3>
<div class="outline-text-3" id="text-5-1">
<ol class="org-ol">
<li value="67"><p>
Šta je SR reza? Nacrtati implementaciju, tablicu prelaska, logički simbol i objasniti ponašanje.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
SR reza je asinhrono memorijsko kolo koje ima mogućnost čuvanja jednobitnog stanja.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">\(S\)</td>
<td class="org-right">\(R\)</td>
<td class="org-left">\(Q\)</td>
<td class="org-right">\(Q^{next}\)</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-left">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-left">-</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-left">-</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-left">-</td>
<td class="org-right">?</td>
</tr>
</tbody>
</table>

<p>
SR reza funkcioniše tako što postavljanjem \((S, R) = (0, 1)\) resetujemo sačuvanu vrednost odnosno čuvamo \(0\), analogno za \((S, R) = (1, 0)\) i \(1\). Kada imamo \((S, R) = (0, 0)\), tada nam izlaz ostaje zapamćena vrednost. Problem sa SR rezom je što kolo ne može da bude stabilno pri ulazu \((S, R) = (1, 1)\)
</p></li>

<li><p>
Šta je D reza? Nacrtati implementaciju, tablicu prelaska, logički simbol i objasniti ponašanje.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
D reza je asinhrono memorijsko kolo koje ima mogućnost čuvanja jednobitnog stanja.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(D\)</td>
<td class="org-right">\(e\)</td>
<td class="org-left">\(Q\)</td>
<td class="org-right">\(Q^{next}\)</td>
</tr>

<tr>
<td class="org-left">-</td>
<td class="org-right">0</td>
<td class="org-left">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">-</td>
<td class="org-right">0</td>
<td class="org-left">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">0</td>
<td class="org-right">1</td>
<td class="org-left">-</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">1</td>
<td class="org-right">1</td>
<td class="org-left">-</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table>

<p>
Imajući u vidu da SR reza ima problem sa nedozvoljenim ulazom \((S, R) = (1, 1)\), jedan od načina na koji bi to moglo da se reši jeste da se uvede ulaz \(D\) (<i>data</i>) koji se direktno povezao sa \(S\), dok bi se njegova negacija na \(R\), čime bi se izgubila mogćnost &ldquo;čitanja memorije&rdquo; odnosno stanja \((S, R) = (0, 0)\) zbog čega se uvodi i ulaz \(e\) (<i>enable</i>) koji se pre povezivanja sa \(S\) odnosno \(R\) konjuguje sa \(D\) odnosno \(\bar{D}\).
</p></li>

<li><p>
Koja je osnovna razlika između reze i flip-flopa?
</p>

<p>
Reza je asinhrono sekvencijalno kolo dok je flip-flop povezan na <b>časovnik</b> odnosno sinhrono sekvencijalno kolo.
</p></li>

<li><p>
Nacrtati implementaciju master-slave SR flip-flopa i objasniti ponašanje
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Imamo dve SR reze, leva je <i>master</i>, desna je <i>slave</i>. Izlazi <i>master</i>-a se prosleđuju i čuvaju u <i>slave</i>-u. Ulazi obe reze kontrolisani su konjunkcijama koje su povezane na signal časovnika. Kada je signal časovnika \(0\), tada su ulazi <i>master</i>-a otvoreni i moguće je menjati vrednost koja se čuva u njemu, dok su ulazi <i>slave</i>-a zatvoreni. Pri uzlaznom rubu ulazi <i>master</i>-a se zatvaraju dok se ulazi <i>slave</i>-a otvaraju i upisuje se ono što je bilo u <i>master</i>-u i na kraju to isto i daje na izlazu. Posledica toga je da do promene stanja može doći isključivo u <b>uzlaznom rubu</b>.
</p>

<p>
U prethodnom objašnjenju je pretpostavljena implementacija koja menja stanje u <b>uzlaznom rubu</b>, suprotnim invertovanjem signala časovnika je moguće implementacija koja menja stanje u <b>silaznom rubu</b>.
</p></li>

<li><p>
Nacrtati implementaciju master-slave D flip-flopa i objasniti ponašanje
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Imamo dve SR reze, leva je <i>master</i>, desna je <i>slave</i>. Izlazi <i>master</i>-a se prosleđuju i čuvaju u <i>slave</i>-u. Ulazi obe reze kontrolisani su konjunkcijama koje su povezane na signal časovnika. Kada je signal časovnika \(0\), tada su ulazi <i>master</i>-a otvoreni i moguće je menjati vrednost koja se čuva u njemu, dok su ulazi <i>slave</i>-a zatvoreni. Pri uzlaznom rubu ulazi <i>master</i>-a se zatvaraju dok se ulazi <i>slave</i>-a otvaraju i upisuje se ono što je bilo u <i>master</i>-u i na kraju to isto i daje na izlazu. Posledica toga je da do promene stanja može doći isključivo u <b>uzlaznom rubu</b>.
</p>

<p>
Kao i kod D reze ulaz pre konjunkcija <i>master</i>-a biva i negiran da bi se eliminisao slučaj \((S, R) = (1, 1)\). Takođe se dodaje i multipleksor koji u zavisnosti od \(e\) bira da li da propusti stari signal ili D.
</p></li>

<li><p>
Nacrtati implementaciju master-slave JK flip-flopa i objasniti ponašanje
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Imamo dve SR reze, leva je <i>master</i>, desna je <i>slave</i>. Izlazi <i>master</i>-a se prosleđuju i čuvaju u <i>slave</i>-u. Ulazi obe reze kontrolisani su konjunkcijama koje su povezane na signal časovnika. Kada je signal časovnika \(0\), tada su ulazi <i>master</i>-a otvoreni i moguće je menjati vrednost koja se čuva u njemu, dok su ulazi <i>slave</i>-a zatvoreni. Pri uzlaznom rubu ulazi <i>master</i>-a se zatvaraju dok se ulazi <i>slave</i>-a otvaraju i upisuje se ono što je bilo u <i>master</i>-u i na kraju to isto i daje na izlazu. Posledica toga je da do promene stanja može doći isključivo u <b>uzlaznom rubu</b>.
</p>

<p>
JK flip-flop rešava problem \((S, R) = (1, 1)\) tako što na konjunkcije ispred ulaza <i>master</i>-a dovodi i izlaze <i>slave</i>-a koji će uvek biti različiti, i time se semantika \((S, R) = (1, 1)\) menja na invertovanje stanja.
</p></li>

<li><p>
Nacrtati implementaciju master-slave T flip-flopa i objasniti ponašanje
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Imamo dve SR reze, leva je <i>master</i>, desna je <i>slave</i>. Izlazi <i>master</i>-a se prosleđuju i čuvaju u <i>slave</i>-u. Ulazi obe reze kontrolisani su konjunkcijama koje su povezane na signal časovnika. Kada je signal časovnika \(0\), tada su ulazi <i>master</i>-a otvoreni i moguće je menjati vrednost koja se čuva u njemu, dok su ulazi <i>slave</i>-a zatvoreni. Pri uzlaznom rubu ulazi <i>master</i>-a se zatvaraju dok se ulazi <i>slave</i>-a otvaraju i upisuje se ono što je bilo u <i>master</i>-u i na kraju to isto i daje na izlazu. Posledica toga je da do promene stanja može doći isključivo u <b>uzlaznom rubu</b>.
</p>

<p>
T flip-flop je praktično JK flip-flop gde su \(J\) i \(K\) spojeni u jedan ulaz, čime je semantika takva da registar može ili da čuva tekuće stanje ili da ga invertuje.
</p></li>

<li><p>
Objasniti problem &ldquo;hvatanja jedinice&rdquo; (<i>1s cathing problem</i>) kod master-slave SR i JK flip-flopova. Na koji način se ovaj problem može rešiti?
</p>

<p>
Kada imamo kratkotrajni šum signala (npr. nagli skok i pad) na jednom od ulaza u fazi časovnika u kojoj se menjaju vrednosti, kod SR, JK i T flip-flopova se zabeleži \(1\) iako se u međuvremenu promenilo na \(0\). Do toga dolazi jer se \(1\) odmah pamti u $master$-u da bi pri promeni na \(0\) to samo dalo signal da se ono što je zapamćeno održi.
</p>

<p>
Moguće je rešiti problem tako što se SR, JK ili T flip-flop svedu na D flip-flop koji ne pati od istog problema tako što se uvede multipleksor koji u zavisnosti od ulaza polaznog flip-flopa bira šta će se dalje propustiti.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org6b0a4d2" class="outline-3">
<h3 id="org6b0a4d2"><span class="section-number-3">5.2</span> Implementacija <code>RAM</code>-a</h3>
<div class="outline-text-3" id="text-5-2">
<ol class="org-ol">
<li value="75"><p>
Šta je registar i kako se implementira? Navesti primer.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Registar dužine \(n\) je kolo koje čuva $n$-bitnu vrednost. Najčešće se implementira preko D flip-flopova koji su svi povezani na zajednički signal časovnika i \(e\) signal.
</p></li>

<li><p>
Statička memorija. Primer realizacije memorije \(4\times4\).
</p>

<p>
Statička memorija se najčešće koristi za implementaciju procesorskih registara i keš memorije.
</p>

<p>
\(4 \times 4\) memorija se sastoji iz \(4\) reda od po \(4\) registra, gde \(4\) registra predstavljaju jednu adresu.
</p>

<p>
I/O:
</p>
<ul class="org-ul">
<li>\(adr\) - adresa nad kojom treba operisati</li>
<li>\(data_in\) - podatke sa kojima treba raditi</li>
<li>\(data_out\) - pročitani podaci</li>
<li>\(wr\) - flag koji označava dozvoljeno pisanje</li>
<li>\(rd\) - flaag koji označva dozvoljeno čitanje</li>
<li>\(clk\) - signal od časovnika</li>
</ul>

<p>
Pisanje:
</p>
<ol class="org-ol">
<li>\(adr\) se prosleđuje dekoderu</li>
<li>rezultat se prosleđuje u konjunkciju sa \(wr\)</li>
<li>to stvara signal \(e\) za sve flip-flopove u tom redu</li>
<li>podaci iz \(data_in\) bivaju upisani u adresu \(adr\)</li>
</ol>

<p>
Čitanje:
</p>
<ol class="org-ol">
<li>\(adr\) se prosleđuje dekoderu</li>
<li>rezultat aktivira bafere sa 3 stanja</li>
<li>dodatni baferi sa 3 stanja se aktiviraju u zavisnosti od \(rd\)</li>
<li>podaci sa adrese \(adr\) bivaju poslati na \(data_out\)</li>
</ol></li>

<li><p>
Na primeru objasniti princip konstrukcije većih memorija pomoću manjih.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div></li>

<li><p>
Efikasna realizacija memorijske ćelije kod statičkih memorija.
</p>

<p>
Da bismo smanjili cenu i kašnjenje signala i ujedno povećali efikasnost težimo da smanjimo broj komponenti potreban za realizaciju nekog kola.
</p>

<p>
Kod asinhronih memorija, gde koristimo reze, bismo mogli umesto D-reza da &ldquo;izvučemo&rdquo; zajedničko NE za jednu kolonu i koristimo SR reze sa dodatnim ulazom \(e\). Na ovaj način smanjujemo broj NE gejtova sa \(mn\) na \(n\).
</p>

<p>
Kod sinhronih memorija, gde koristimo flip-flopove u <i>master-slave</i> organizaciji, tada bismo mogli umesto da svaki flip-flop ima svog <i>master</i>-a uvedemo jednog <i>master</i>-a za jednu kolonu, koji će dalje naći svog <i>slave</i>-a pomoću dekodera. Potrebna su i \(2\) reza koja će da pamte adresu. Na ovaj način smanjujemo broj potrebnih reza sa \(2mn\) na \(mn + n + 2\), što je značajna ušteda.
</p></li>

<li><p>
Objasniti princip rada memorijske ćelije kod dinamičkih memorija.
</p>

<p>
Svaka ćelija za čuvanje jednog bita se sastoji iz jednog tranzistora i kondenzatora. Vrednost bita se čuva naelektrisanjem kondenzatora. Pun kondenzator odgovara \(1\), dok prazan odgovara \(0\). Kada želimo da upišemo vrednost, na <b>bitsku liniju</b> dovodimo odgovarajuću vrednost i aktiviramo <b>liniju reči</b> čime se otvara tranzistor i zbog toga se kondenzator puni ili prazni u zavisnosti od vrednosti koju želimo da upišemo. Prilikom čitanja <b>bitska linija</b> se naelektriše na neki međupotencijal (npr. 2.5V), pa se aktivira <b>linija reči</b> zbog čega će se potencijal na liniji reči blago promeniti u odnosu na vrednost koja je sačuvana, što će pojačavač registrovati i &ldquo;pojačati&rdquo; ka 0V ili 5V. Prilikom čitanja uništavamo zapisanu vrednost, tako da je potrebno nakon čitanja da je opet i upišemo. Kondenzator se vremenom sam prazni, tako da je potrebno periodično vršiti osvežavanje kompletne memorije.
</p></li>

<li><p>
Prednosti i nedostaci dinamičkih memorija u odnosu na statičke.
</p>

<p>
Prednosti:
</p>
<ul class="org-ul">
<li>Manji broj tranzistora i komponenti, dakle manja cena</li>
</ul>
<p>
Mane:
</p>
<ul class="org-ul">
<li>Dosta sporije čitanje i pisanje u odnosu na statičke</li>
<li>Komplikovaniji proces sinhronizacije zbog većeg broja mogućih operacija nad memorijom</li>
</ul></li>

<li><p>
Šta je pomerački registar i gde se obično koristi?
</p>

<p>
What the actual fuck
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orgf38ec3e" class="outline-3">
<h3 id="orgf38ec3e"><span class="section-number-3">5.3</span> Binarni brojač</h3>
<div class="outline-text-3" id="text-5-3">
<ol class="org-ol">
<li value="82"><p>
Asinhroni binarni brojač. Nacrati šemu i objasniti princip rada. Koji je osnovni nedostatak asinhronih brojača?
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Implementiramo ga preko nekoliko T flip-flopova tako što je onaj koji čuva bit najniže vrednosti direktno povezan na signal časovnika. Svi T flip-flopovi za ulaz primaju \(1\). Izlaz $N - 1$og T flip-flopa predstavlja signal časovnika, što znači da do promene dolazi samo ako je signal časovnika prešao sa \(1\) na \(0\), zbog čega se javlja &ldquo;talasasti&rdquo; efekat odnosno kašnjenje je \(O(N)\), za \(N\) - broj T flip-flopova.
</p>

<p>
Glavni nedostatak je vremenska neefikasnost.
</p></li>

<li><p>
Sinhroni binarni brojač. Nacrtati šemu i objasniti princip rada.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Implementiramo ga preko nekoliko JK flip-flopova tako što ih povežemo sve sa časovnikom. Odluku da li da menjamo $i$-ti flip-flop donosimo na osnovu konjunkcije izlaza svih prethodnih flip-flopova. Na ovaj način nam se usložnjvaju AND gejtovi, zbog čega je kašnjenje \(O(logN)\), za \(N\) - broj JK flip-flopova.
</p></li>

<li><p>
Dizajn brojača sa proizvoljnim redosledom stanja. Primer.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
U slučaju da nam je potrebno da imamo brojač koji neće ići po <i>&ldquo;default&rdquo;</i> redosledu, već nekim našim, potreban nam je brojač sa proizvoljnim redosledom stanja.
</p>

<ol class="org-ol">
<li>Nacrtamo <i>state machine</i> \/ graf prelaska stanja</li>
<li>Prebacimo to u tablični oblik i odredimo vrednosti \(J_{i}\) i \(K_{i}\) potrebne za svaki prelazak stanja</li>
<li>Preko Karnoovih mapa minimizujemo za svako \(J_{i}\) i \(K_{i}\)</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-orgcc61e04" class="outline-3">
<h3 id="orgcc61e04"><span class="section-number-3">5.4</span> Konačni automati i transduktori</h3>
<div class="outline-text-3" id="text-5-4">
<ol class="org-ol">
<li value="85"><p>
Konačni automati i transduktori kao model sinhronih sekvencijalnih kola. Dizajn konačnih transduktora. Primer.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div>

<p>
Brojač sa ulazom kojim kontrolišemo u koje stanje će preći nazivamo <b>konačni automat</b>. Ukoliko to kolo prilikom svake promene stanja generiše novu vrednost na izlazu, onda to kolo nazivamo <b>konačni transduktor</b>.
</p>

<p>
Konačni transduktori predstavljaju opšti model sinhronih sekvencijalnih kola.
</p>

<ol class="org-ol">
<li>Definišemo tablicu prelaska
<ul class="org-ul">
<li>\(Q\) - trenutno stanje</li>
<li>\(X\) - ulaz</li>
<li>\(Q^{next}\) - sledeće stanje</li>
<li><p>
\(Y\) - izlaz
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">\(Q\)</td>
<td class="org-right">\(X\)</td>
<td class="org-right">\(Q^{next}\)</td>
<td class="org-right">Y</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
</ul></li>

<li>Nacrtamo graf

<ul class="org-ul">
<li>Stanja su čvorovi</li>
<li>Grane su usmerene od trenutnog ka sledećem stanju</li>
<li>&ldquo;Težine&rdquo; su formata \(X/Y\), odnosno ako smo na stanju \(Q\) sa ulazom \(X\) preći ćemo na \(Q^{next}\) i na izlazu ispisati \(Y\)</li>
</ul></li>
</ol></li>

<li><p>
Ukratko objasniti osnovni princip dizajna kontrolne jedinice kao konačnog transduktora.
</p>

<p>
What the fuck?
</p></li>

<li>Navesti primer opisa nekog algoritma u formi konačnog transduktora (samo tablica prelaska, bez realizacije samog transduktora)

<ul class="org-ul">
<li>\(Q\) - trenutno stanje</li>
<li>\(X\) - ulaz</li>
<li>\(Q^{next}\) - sledeće stanje</li>
<li><p>
\(Y\) - izlaz
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">\(Q\)</td>
<td class="org-right">\(X\)</td>
<td class="org-right">\(Q^{next}\)</td>
<td class="org-right">Y</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
<td class="org-right">3</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">1</td>
<td class="org-right">2</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">1</td>
<td class="org-right">0</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
</ul></li>
</ol>
</div>
</div>
</div>

<div id="outline-container-org3e07115" class="outline-2">
<h2 id="org3e07115"><span class="section-number-2">6</span> Arhitektura i organizacija</h2>
<div class="outline-text-2" id="text-6">
<ol class="org-ol">
<li value="88">Šta je arhitektura a šta organizacija računara?

<ul class="org-ul">
<li>Arhitektura računara je apstraktni model koji opisuje računar iz ugla programera kog zanima koje instrukcije postoje, načini adresiranja, kako se predstavljaju podaci i sl.
<ul class="org-ul">
<li>Odgovara na pitanje <b>Šta radi računar?</b></li>
</ul></li>
<li>Organizacija računara je implementacija arhitekture gde se posmatraju veze između komponenti, <i>low-level</i> opis kako se određene operacije obavljaju
<ul class="org-ul">
<li>Odgovara na pitanje <b>Kako radi računar?</b></li>
</ul></li>
</ul></li>

<li><p>
Šta obuhvata ISA (<i>instruction set architecture</i>)?
</p>

<p>
ISA obuhvata:
</p>
<ul class="org-ul">
<li>koje instrukcije postoje</li>
<li>koji načini upravljanja memorijom hardver podržava (načine adresiranja, virtuelna memorija, konzistentnost memorije)</li>
<li>kako se predstavljaju podaci</li>
</ul></li>

<li><p>
Šta su troadresni procesori? Primer instrukcija i koda. Karakteristike.
</p>

<p>
Troadresni procesor je procesor koji u instrukciji može da ima tri adrese. Programi na troadresnom računaru su kompaktni, ali samo instrukcije mogu da budu glomazne zbog zahteva za čuvanjem 3 operanda.
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">ADD</span> <span style="color: #ff2afc; font-weight: bold;">C</span>, A, B
<span style="color: #42c6ff; font-weight: bold;">MUL</span> <span style="color: #ff2afc; font-weight: bold;">C</span>, A, B
</pre>
</div></li>

<li><p>
Šta su dvoadresni procesori? Primer instrukcija i koda. Karakteristike.
</p>

<p>
Dvoadresni procesori su procesori koji mogu da imaju maksimalno dve adrese u instrukciji. Rezultat operacije se upisuje u neku privremenu lokaciju ili u lokaciju jednog od operanada. Smanjuje se dužina programa, ubrzava izvršavanje, ali se ponekad koristi dodatna memorija.
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">LOAD</span> <span style="color: #ff2afc; font-weight: bold;">B</span>, A
<span style="color: #42c6ff; font-weight: bold;">ADD</span> <span style="color: #ff2afc; font-weight: bold;">A</span>, B
</pre>
</div></li>

<li><p>
Šta su jednoadresni procesori? Primer instrukcija i koda. Karakteristike.
</p>

<p>
Jednoadresni procesori su procesori koji imaju jednu adresu u instrukciji. Operacije koje zahtevaju dva operanda se razrešavaju tako što je druga adresa implicitna. Ovi računari se često obraćaju memoriji za upis i čitanje međurezultata. Programi su dosta dugački i izvršavanje je relativno sporo. Koriste se u situacijama kada je memorija dosta skupa.
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">LOAD</span> <span style="color: #ff2afc; font-weight: bold;">X</span>
<span style="color: #42c6ff; font-weight: bold;">ADD</span> <span style="color: #ff2afc; font-weight: bold;">X</span>
<span style="color: #42c6ff; font-weight: bold;">STORE</span> <span style="color: #ff2afc; font-weight: bold;">X</span>
</pre>
</div></li>

<li><p>
Šta su nuloadresni procesori? Primer instrukcija i koda. Karakteristike.
</p>

<p>
Nuloadresni procesori su procesori gde je maksimalan broj adresa u instrukciji \(0\) osim kod instrukcija <code>PUSH</code> i <code>POP</code>. Takvi procesori implicitno adresiraju svoje operande (često stavljajući ih na stek), što predstavlja veliko ograničenje, pa se koriste samo u specijalnim slučajevima.
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">PUSH</span> <span style="color: #ff2afc; font-weight: bold;">A</span>
<span style="color: #42c6ff; font-weight: bold;">PUSH</span> <span style="color: #ff2afc; font-weight: bold;">B</span>
<span style="color: #42c6ff; font-weight: bold;">ADD</span>
<span style="color: #42c6ff; font-weight: bold;">POP</span>
</pre>
</div></li>

<li><p>
Objasniti odnos performansi i broja adresa.
</p>

<p>
Instrukcije sa većim brojem adresa su moćnije, programi kompaktniji i veća je brzina izvršavanja. S povećanjem broja adresa raste i složenost instrukcije što otežava konstrukciju procesora i produžava vreme potrebno za prepoznavanje operacionog koda.
</p></li>

<li><p>
Šta je <code>LOAD/STORE</code> arhitektura? Objasniti.
</p>

<p>
Sve operacije se izvršavaju isključivo nad registrima procesora. Samo operacije <code>LOAD</code> i <code>STORE</code> mogu da pristupaju memoriji. <code>RISC</code> i vektorski procesori često koriste ovakvu arhitekturu. Prednost je smanjenje složenosti dekodiranja zbog manjeg broja instrukcija.
</p></li>

<li><p>
Karakteristike <code>CISC</code> arhitekture.
</p>

<p>
Ciljevi:
</p>
<ul class="org-ul">
<li>složena arhitektura skupa instrukcija</li>
<li>raznovrsnost operacija</li>
<li>raznovrsnost načina adresiranja itd.</li>
</ul>

<p>
Posledice:
</p>
<ul class="org-ul">
<li>Iz velikog skupa instrukcija se koristi oko 20%, dok se ostale ređe koriste</li>
<li>Otežano dekodiranja zbog velikog broja instrukcija i načina adresiranja</li>
</ul></li>

<li><p>
Karakteristike <code>RISC</code> arhitekture.
</p>

<p>
Ciljevi:
</p>
<ul class="org-ul">
<li>jednostavna arhitektura skupa instrukcija</li>
<li>obezbeđivanje minimalnog skupa instrukcija i načina adresiranja</li>
<li>povećan broj registara koji se mogu koristiti za računanje</li>
</ul>

<p>
Posledice:
</p>
<ul class="org-ul">
<li>stalniji skup instrukcija</li>
<li>jednostavno dekodiranje</li>
<li>kraće trajanje izvršavanja</li>
<li>jednostavnija implementacija procesora</li>
</ul></li>

<li><p>
Odnos <code>RISC</code> i <code>CISC</code> arhitektura.
</p>

<p>
Danas procesori najčešće predstavljaju hibride ove dve arhitekture.
</p>

<p>
<code>RISC</code> &gt; <code>CISC</code>:
</p>
<ul class="org-ul">
<li>jednostavnija konstrukcija zbog manjeg broja instrukcija</li>
<li>manje vremena je potrebno za izradu samog procesora</li>
<li>bolje performanse jer je lakše definisati prevodioce koji formiraju optimalniji kod nego <code>CISC</code> procesori</li>
</ul>

<p>
<code>CISC</code> &gt; <code>RISC</code>:
</p>
<ul class="org-ul">
<li>veća količina softvera je napisana za <code>CISC</code> arhitekturu</li>
</ul></li>

<li>Struktura i format mašinske instrukcije

<ul class="org-ul">
<li>strukturu čine:
<ol class="org-ol">
<li>operacioni kod</li>
<li>operandi</li>
</ol></li>
<li>format instrukcije određuje način kodiranja ranijepomenutih komponenti u binarnom obliku (implicitno određuje i dužinu instrukcije)</li>
</ul></li>

<li>Vrste operanada mašinske instrukcije

<ol class="org-ol">
<li>Registarski</li>
<li>Memorijski</li>
<li>Neposredni (konstante)</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-org5452d6c" class="outline-2">
<h2 id="org5452d6c"><span class="section-number-2">7</span> Adresiranje</h2>
<div class="outline-text-2" id="text-7">
<ol class="org-ol">
<li value="101"><p>
Objasniti direktno adresiranje memorijskih operanada.
</p>

<p>
Stvarna adresa se direktno uključuje u instrukciju. Adrese koje se javljaju u ovom načinu adresiranja se još nazivaju i apsolutne adrese. Ovaj način adresiranja je relativno jednostavan jer nema izračunavanja adrese, a prenos operanada zahteva samo jedno referisanje memorije.
</p></li>

<li><p>
Objasniti indirektno adresiranje memorijskih operanada.
</p>

<p>
Kod indirektnog adresiranja je poznata samo adresa lokacije na kojoj se nalazi adresa operanda, pa se do te adrese dolazi indirektno, tj. instrukcija sadrži binarni kod regista procesora čija se vrednost koristi kao adresa memorijskog operanda. Ovaj način adresiranja zahteva dva ciklusa, jedan za čitanje adrese, drugi za čitanje samog operanda.
</p></li>

<li><p>
Objasniti indeksno adresiranje memorijskih operanada.
</p>

<p>
Instrukcija sadrži binarne kodove dva registra čije se vrednosti sabiraju i tako dobijamo adresu memorijskog operanda. Obično je vrednost jednog registra fiksirana, a drugi predstavlja indeks koji se pomera. Korisno je za pristup elementima niza.
</p>

<ul class="org-ul">
<li>Skalirano indeksno adresiranje:
<ul class="org-ul">
<li>Vrednost indeksnog registra se može množiti konstantom (npr. \(4\) ili \(8\)) pre sabiranja sa baznim registrom.</li>
</ul></li>

<li>Apsolutno indeksno adresiranje:
<ul class="org-ul">
<li>Bazna adresa ne mora biti u registru, već može biti zadata kao apsolutna adresa na koju se dodaje vrednost indeksnog registra (uz eventualno prethodno skaliranje)</li>
</ul></li>
</ul></li>

<li><p>
Objasniti relativno adresiranje memorijskih operanada.
</p>

<p>
U ovom načinu za adresiranje se kao registar koristi brojač instrukcija (<code>PC</code> <i>program counter</i>) čiji sadržaj se uzima kao <b>početna adresa</b>. U adresni deo instrukcije se upisuje ceo broj koji predstavlja udaljenje od početne adrese. Relativno adresiranje se koristi kada znamo da je ciljana adresa negde u okolini tekuće.
</p></li>

<li><p>
Objasniti načine adresiranja na <i>x86-64</i> arhitekturi.
</p>

<p>
Načini adresiranja opisuju kako se određuje operand instrukcije.
</p>

<ul class="org-ul">
<li><p>
<b>Neposredno</b> za konstante:
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">rax</span>, <span style="color: #ffd400; font-weight: bold;">42</span>
</pre>
</div></li>
<li><p>
<b>Registarsko</b>:
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">rax</span>, rdi
</pre>
</div></li>
<li><b>Memorijsko</b>:
<ul class="org-ul">
<li><p>
Direktno
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">value</span> <span style="color: #ff2afc; font-weight: bold;">dword</span> <span style="color: #ffd400; font-weight: bold;">42</span>
...
<span style="color: #42c6ff; font-weight: bold;">add</span> <span style="color: #ff2afc; font-weight: bold;">eax</span>, [value]
</pre>
</div></li>
<li><p>
Indirektno
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #546A90;">; </span><span style="color: #546A90;">rdi je pokaziva&#269; na prvi element niza</span>
<span style="color: #42c6ff; font-weight: bold;">add</span> <span style="color: #ff2afc; font-weight: bold;">eax</span>, [rdi]
</pre>
</div></li>
<li><p>
Indeksno
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #546A90;">; </span><span style="color: #546A90;">rdi je pokaziva&#269; na prvi element niza</span>
<span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">rsi</span>, <span style="color: #ffd400; font-weight: bold;">3</span>
<span style="color: #42c6ff; font-weight: bold;">add</span> <span style="color: #ff2afc; font-weight: bold;">eax</span>, [rdi + <span style="color: #ffd400; font-weight: bold;">4</span> * rsi]
</pre>
</div></li>
</ul></li>
</ul></li>

<li><p>
Objasniti načine adresiranja na <i>ARM</i> arhitekturi.
</p>

<p>
Načini adresiranja opisuju kako se određuje operand instrukcije.
</p>

<ul class="org-ul">
<li><p>
<b>Neposredno</b> za konstante:
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">r0</span>, r0, <span style="color: #ffd400; font-weight: bold;">42</span>
</pre>
</div></li>
<li><p>
<b>Registarsko</b>:
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">r0</span>, r1
</pre>
</div></li>
<li><b>Memorijsko</b>:
<ul class="org-ul">
<li><p>
Direktno
</p>
<div class="error">
<p>
Bleji eax, izmeni
</p>

</div>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">value</span> <span style="color: #ff2afc; font-weight: bold;">dword</span> <span style="color: #ffd400; font-weight: bold;">42</span>
...
<span style="color: #42c6ff; font-weight: bold;">add</span> <span style="color: #ff2afc; font-weight: bold;">eax</span>, [value]
</pre>
</div></li>
<li><p>
Indirektno
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #546A90;">; </span><span style="color: #546A90;">r1 je pokaziva&#269; na prvi element niza</span>
<span style="color: #42c6ff; font-weight: bold;">add</span> <span style="color: #ff2afc; font-weight: bold;">r0</span>, [r1]
</pre>
</div></li>
<li>Indeksno
<ul class="org-ul">
<li><p>
Prefiksno bez update-a
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #546A90;">; </span><span style="color: #546A90;">r1 je pokaziva&#269; na prvi element niza</span>
<span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">r2</span>, #<span style="color: #ffd400; font-weight: bold;">3</span>
<span style="color: #42c6ff; font-weight: bold;">ldr</span> <span style="color: #ff2afc; font-weight: bold;">r0</span>, [r1, r2, lsl #<span style="color: #ffd400; font-weight: bold;">2</span>] <span style="color: #546A90;">; </span><span style="color: #546A90;">r0 = *(r1 + 4 * r2)</span>
</pre>
</div></li>
<li><p>
Prefiksno sa update-om
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #546A90;">; </span><span style="color: #546A90;">r1 je pokaziva&#269; na prvi element niza</span>
<span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">r2</span>, #<span style="color: #ffd400; font-weight: bold;">3</span>
<span style="color: #42c6ff; font-weight: bold;">ldr</span> <span style="color: #ff2afc; font-weight: bold;">r0</span>, [r1, r2, lsl #<span style="color: #ffd400; font-weight: bold;">2</span>]! <span style="color: #546A90;">; </span><span style="color: #546A90;">r1 = r1 + 4 * r2; r0 = *r1;</span>
</pre>
</div></li>
<li><p>
Postfiksno sa update-om
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #546A90;">; </span><span style="color: #546A90;">r1 je pokaziva&#269; na prvi element niza</span>
<span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">r2</span>, #<span style="color: #ffd400; font-weight: bold;">3</span>
<span style="color: #42c6ff; font-weight: bold;">ldr</span> <span style="color: #ff2afc; font-weight: bold;">r0</span>, [r1], #<span style="color: #ffd400; font-weight: bold;">4</span> <span style="color: #546A90;">; </span><span style="color: #546A90;">r0 = *r1; r1 = r1 + 4;</span>
</pre>
</div></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org33fa976" class="outline-2">
<h2 id="org33fa976"><span class="section-number-2">8</span> Assembler</h2>
<div class="outline-text-2" id="text-8">
<ol class="org-ol">
<li value="107">Instrukcije transfera. Funkcija i primer upotrebe. (<i>x86-64, ARM</i>)
<ul class="org-ul">
<li><code>x86-64</code>
<ul class="org-ul">
<li><code>mov, movzx, movsx</code>
<ul class="org-ul">
<li><code>dest</code>
<ul class="org-ul">
<li>registar</li>
<li>memorija</li>
</ul></li>
<li><code>src</code>
<ul class="org-ul">
<li>konstanta</li>
<li>registar</li>
<li><p>
memorija
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">dest</span>, src <span style="color: #546A90;">; </span><span style="color: #546A90;">kopira iz src u dest</span>

<span style="color: #42c6ff; font-weight: bold;">movzx</span> <span style="color: #ff2afc; font-weight: bold;">dest</span>, src <span style="color: #546A90;">; </span><span style="color: #546A90;">kopira iz src u dest i pro&#353;iruje 0</span>

<span style="color: #42c6ff; font-weight: bold;">movsx</span> <span style="color: #ff2afc; font-weight: bold;">dest</span>, src <span style="color: #546A90;">; </span><span style="color: #546A90;">kopira iz src u dest i pro&#353;iraje znakom</span>
</pre>
</div></li>
</ul></li>
</ul></li>
<li><code>lea</code>
<ul class="org-ul">
<li><code>dest</code>
<ul class="org-ul">
<li>registar</li>
</ul></li>
<li><code>src</code>
<ul class="org-ul">
<li>konstanta</li>
<li>registar</li>
<li><p>
memorija
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">lea</span> <span style="color: #ff2afc; font-weight: bold;">dest</span>, src <span style="color: #546A90;">; </span><span style="color: #546A90;">kopira adresu od src u dest</span>
</pre>
</div></li>
</ul></li>
</ul></li>
</ul></li>
<li><code>ARM</code>
<ul class="org-ul">
<li><code>ldr/str</code>
<ul class="org-ul">
<li><code>ldr</code>: Učitava vrednost sa adrese u registar</li>
<li><code>str</code>: Čuva vrednost registra na adresi</li>
<li><code>op{&lt;cond&gt;}{&lt;size&gt;} Rn, &lt;adress&gt;</code>
<ul class="org-ul">
<li><code>&lt;cond&gt; = {eq: =, gt: &gt;, ge: &gt;=, lt: &lt;, le: &lt;=}</code></li>
<li><code>&lt;size&gt; = {'': word, b: byte, h: halfword}</code></li>
</ul></li>
</ul></li>
<li><code>ldm/stm</code>
<ul class="org-ul">
<li><code>ldm</code>: Učitava vrednosti u više registara počevši od adrese</li>
<li><code>stm</code>: Čuva vrednosti više registara počevši od adrese</li>
<li><code>op{&lt;adrr_mode&gt;}{&lt;cond&gt;} Rn{!}, &lt;reg_list&gt;</code>
<ul class="org-ul">
<li><code>&lt;adrr_mode&gt; = {IA: increment_after, DB: decrement_before}</code></li>
<li><code>&lt;cond&gt; = {eq: =, gt: &gt;, ge: &gt;=, lt: &lt;, le: &lt;=}</code></li>
<li><code>! updateuje Rn za</code> \(\pm 4 \cdot len(reg\_list)\) <code>u zavisnosti od &lt;adrr_mode&gt;</code></li>
<li><code>&lt;reg_list&gt; je lista registara navedena između { } koja ne sme da sadrži Rn</code></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>

<li><p>
Aritmetičko-logičke instrukcije. (<i>x86-64, ARM</i>)
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div></li>

<li><p>
Instrukcije bezuslovnog skoka. (<i>x86-64, ARM</i>)
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div></li>

<li>Flegovi procesora <code>(O, S, Z, C)</code>. Kada se postavljaju i čemu služe?
<ul class="org-ul">
<li>Postavljaju se nakon određenih operacija
<ul class="org-ul">
<li><p>
Kod <code>x86-64</code> se to radi automatski, npr.
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">cmp</span> <span style="color: #ff2afc; font-weight: bold;">eax</span>, edi <span style="color: #546A90;">; </span><span style="color: #546A90;">bi&#263;e updateovani O, S i Z flegovi</span>
<span style="color: #42c6ff; font-weight: bold;">add</span> <span style="color: #ff2afc; font-weight: bold;">eax</span>, esi <span style="color: #546A90;">; </span><span style="color: #546A90;">bi&#263;e updateovani O, Z, C flegovi PROVERI</span>
</pre>
</div></li>
<li><p>
Kod <code>ARM</code> se to radi tako što se dodaje sufiks <code>s</code> na operacije kojima to po <i>default</i>-u nije tako
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">cmp</span> <span style="color: #ff2afc; font-weight: bold;">r0</span>, r1 <span style="color: #546A90;">; </span><span style="color: #546A90;">bi&#263;e updateovani O, S i Z flegovi</span>
<span style="color: #42c6ff; font-weight: bold;">adds</span> <span style="color: #ff2afc; font-weight: bold;">r0</span>, r2 <span style="color: #546A90;">; </span><span style="color: #546A90;">bi&#263;e updateovani O, Z, C flegovi PROVERI</span>
</pre>
</div></li>
</ul></li>
<li><code>O</code> (overflow) - prekoračenje kod označenih operatora
<ul class="org-ul">
<li>govori da li je došlo do prekoračenja</li>
</ul></li>
<li><code>S</code> (sign) - najveći bit rezultata
<ul class="org-ul">
<li>govori da li je broj negativan ili nenegativan (\(x < 0 \ \lor x \leq 0\))</li>
</ul></li>
<li><code>Z</code> (zero)
<ul class="org-ul">
<li>govori da li je rezultat prethodne operacije \(0\)</li>
</ul></li>
<li><code>C</code> (carry)
<ul class="org-ul">
<li>govori da li je došlo do prenosa na bitu najveće težine</li>
</ul></li>
</ul></li>

<li><p>
Instrukcije poređenja i njihova uloga u realizaciji uslovnih skokova. (<i>x86-64, ARM</i>)
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div></li>

<li><p>
Instrukcije uslovnog skoka. (<i>x86-64, ARM</i>)
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div></li>

<li>Koju kombinaciju flegova testira instrukcija <code>jl</code>, a koju <code>jb</code> na <code>x86-64</code> arhitekturi?

<ul class="org-ul">
<li><code>jl</code>: \(S \oplus O\)</li>
<li><code>jb</code>: \(C\)</li>
</ul></li>

<li><p>
Objasniti pozivanje procedura i vraćanje iz njih korišćenjem steka za čuvanje povratne adrese. Prednosti i mane.
</p>

<p>
Pre pozivanja procedure na stek se čuva povratna adresa. Kada se procedura izvrši, instrukcija povratka uzima vrednost povratne adrese sa steka kako bi povratila kontrolu instrukciji koja sledi nakon zvanja procedure.
</p>

<p>
Mane:
</p>
<ul class="org-ul">
<li>sporije nego čuvanje u registrima</li>
</ul>
<p>
Prednosti:
</p>
<ul class="org-ul">
<li>nemamo ograničen broj parametara koji možemo čuvati na steku što je pogodno za rekurzivne procedure</li>
</ul></li>

<li><p>
Objasniti pozivanje procedura i vraćanje iz njih korišćenjem registara za čuvanje povratne adrese. Prednosti i mane.
</p>

<p>
Pre pozivanja procedure u poseban registar se čuva povratna adresa. Kada se procedura izvrši, instrukcija povratka uzima vrednost povratna adrese iz tog registra kako bi povratila kontrolu instrukciji koja sledi nakon zvanja procedure.
</p>

<p>
Mane:
</p>
<ul class="org-ul">
<li>imamo ograničen broj parametara koji možemo čuvati zbog ograničenog broja registara</li>
</ul>
<p>
Prednosti:
</p>
<ul class="org-ul">
<li>brže nego čuvanje na steku</li>
</ul></li>

<li><p>
Objasniti prenos argumenata procedure korišćenjem steka. Prednosti i mane.
</p>

<p>
Parametri se postavljaju na stek i pozvana procedura mora da ih vrati.
</p>

<p>
Mane:
</p>
<ul class="org-ul">
<li>sporije nego registarski</li>
</ul>
<p>
Prednosti:
</p>
<ul class="org-ul">
<li>nemamo ograničen broj parametara, što je pogodno za rekurzivne procedure</li>
</ul></li>

<li><p>
Objasniti prenos argumenata procedure korišćenjem registra procesora. Prednosti i mane.
</p>

<p>
Pre pozivanja procedure vrednosti koje bi trebalo da joj prosledimo stavljamo u registre koje će koristiti pozvana procedura
</p>

<p>
Mane:
</p>
<ul class="org-ul">
<li>imamo ograničen broj parametara zbog ograničenog broja registara</li>
</ul>
<p>
Prednosti:
</p>
<ul class="org-ul">
<li>brže nego čuvanje na steku</li>
</ul></li>

<li><p>
Na koji način pozvana funkcija može vratiti vrednost pozivajućoj funkciji?
</p>

<p>
Putem steka i registara.
</p></li>

<li><p>
Objasniti pozivanje funkcija na <code>x86-64</code> arhitekturi. Kako se prenosi adresa povratka, argumenti, kao i povratna vrednost?
</p>

<p>
Prvih 6 argumenata se prosleđuju redom u registre:
</p>
<ol class="org-ol">
<li><code>rdi</code></li>
<li><code>rsi</code></li>
<li><code>rdx</code></li>
<li><code>rcx</code></li>
<li><code>r8</code></li>
<li><p>
<code>r9</code>
</p>

<p>
U slučaju da nam je potrebno više od 6 argumenata, postavljamo ih na stek zdesna ulevo.
</p>

<p>
Povratna vrednost se čuva u registru <code>rax</code>.
</p>

<div class="org-src-container">
<pre class="src src-asm">     <span style="color: #ff2afc; font-weight: bold;">mov</span> edi, <span style="color: #ffd400; font-weight: bold;">42</span>
     <span style="color: #ff2afc; font-weight: bold;">mov</span> esi, <span style="color: #ffd400; font-weight: bold;">7</span>
     <span style="color: #ff2afc; font-weight: bold;">call</span> f
     <span style="color: #ff2afc; font-weight: bold;">add</span> r10d, eax <span style="color: #546A90;">; </span><span style="color: #546A90;">sum += eax</span>
</pre>
</div>

<p>
Instrukcija <code>call</code> postavlja adresu sledeće instrukcije na stek kao adresu povratka.
</p></li>
</ol></li>

<li><p>
Objasniti pozivanje funkcija na <code>ARM</code> arhitekturi. Kako se prenosi adresa povratka, argumenti, kao i povratna vrednost?
</p>

<p>
Prvih 4 argumenata se prosleđuju redom u registre:
</p>
<ol class="org-ol">
<li><code>r0</code></li>
<li><code>r1</code></li>
<li><code>r2</code></li>
<li><p>
<code>r3</code>
</p>

<p>
U slučaju da nam je potrebno više od 4 argumenata, postavljamo ih na stek zdesna ulevo.
</p>

<p>
Povratna vrednost se čuva u registru <code>r0</code>.
</p>

<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">r0</span>, <span style="color: #ffd400; font-weight: bold;">42</span>
<span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">r1</span>, <span style="color: #ffd400; font-weight: bold;">7</span>
<span style="color: #42c6ff; font-weight: bold;">bl</span> <span style="color: #ff2afc; font-weight: bold;">f</span>
<span style="color: #42c6ff; font-weight: bold;">add</span> <span style="color: #ff2afc; font-weight: bold;">r4</span>, r0 <span style="color: #546A90;">; </span><span style="color: #546A90;">sum += eax</span>
</pre>
</div></li>
</ol>

<p>
Instrukcija <code>bl</code> postavlja adresu sledeće instrukcije u <code>lr</code> (<i>link register</i>) kao adresu povratka.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org59dbce1" class="outline-2">
<h2 id="org59dbce1"><span class="section-number-2">9</span> Procesor</h2>
<div class="outline-text-2" id="text-9">
<ol class="org-ol">
<li value="121">Koje su osnovne komponente procesora? Objasniti ih.

<ul class="org-ul">
<li><code>ALU</code> - Aritmetičko logička jedinica
<ul class="org-ul">
<li>zadužena je za aritmetičke i logičke operacije nad podacima</li>
<li>kombinatorno kolo</li>
<li>obradu podataka vrši isključivo nad registrima</li>
<li>danas se ne implementira kao jedinstvena komponenta, već iz nekoliko specijalizovanih podjedinica</li>
</ul></li>
<li><code>CU</code> - Kontrolna jedinica
<ul class="org-ul">
<li>zadužena je za kontrolu redosleda izvršavanja operacija u <code>ALU</code> i kontrolu prenosa podataka i instrukcija iz i u procesor.</li>
<li>sekvencijalno kolo</li>
</ul></li>
</ul></li>

<li>Šta je <code>ALU</code> i čemu služi?

<ul class="org-ul">
<li><code>ALU</code> - Aritmetičko logička jedinica
<ul class="org-ul">
<li>zadužena je za aritmetičke i logičke operacije nad podacima</li>
<li>kombinatorno kolo</li>
<li><code>ALU</code> obradu podataka vrši isključivo nad registrima</li>
<li>danas se ne implementira kao jedinstvena komponenta, već iz nekoliko specijalizovanih podjedinica</li>
</ul></li>
</ul></li>

<li><p>
Šta su registri opšte namene i čemu služe?
</p>

<p>
Registri opšte namene su procesorski registri kojima programer ima pristup, nad kojima je moguće vršiti računanje i privremeno čuvanje podataka.
</p></li>

<li><p>
Čemu služi instrukcioni registar <code>IR</code>?
</p>

<p>
<code>IR</code> sadrži instrukciju koja se trenutno izvršava ili dekodira.
</p>

<p>
Spada u <b>registre specijalne namene</b>, odnosno <b>nije</b> registar opšte namene.
</p></li>

<li><p>
Čemu služi programski brojač <code>PC</code>?
</p>

<p>
<code>PC</code> sadrži adresu naredne instrukcije koja treba da se izvrši.
</p>

<p>
Spada u <b>registre specijalne namene</b>, odnosno <b>nije</b> registar opšte namene.
</p></li>

<li><p>
Čemu služi statusni registar <code>PSW</code>?
</p>

<p>
<code>PSW</code> = Program Status Word
</p>

<p>
<code>PSW</code> sadrži informacije o trenutnom stanju (<i>state</i>) procesora, odnosno flegove.
</p>

<p>
Spada u <b>registre specijalne namene</b>, odnosno <b>nije</b> registar opšte namene.
</p></li>

<li><p>
Čemu služi registar memorijskih adresa <code>MAR</code>?
</p>

<p>
<code>MAR</code> = memory adress register
</p>

<p>
<code>MAR</code> sadrži memorijsku adresu sledećeg podataka ili instrukcije koji će procesor da obradi ili da sačuva na to mesto.
</p>

<p>
Predstavlja medijum komunikacije između procesora i adresne magistrale.
</p>

<p>
Spada u <b>registre specijalne namene</b>, odnosno <b>nije</b> registar opšte namene.
</p></li>

<li><p>
Čemu služi registar memorijskih podataka <code>MDR</code>?
</p>

<p>
<code>MDR</code> = memory data register
</p>

<p>
<code>MDR</code> sadrži vrednost sledećeg podataka koji će procesor da obradi ili da sačuva negde u memoriji
</p>

<p>
Predstavlja medijum komunikacije između procesora i data magistrale.
</p>

<p>
Spada u <b>registre specijalne namene</b>, odnosno <b>nije</b> registar opšte namene.
</p></li>

<li><p>
Šta je putanja podataka (<i>datapath</i>) i iz čega se sastoji?
</p>

<p>
<i>Datapath</i> je deo procesora koji se sastoji iz registara, <code>ALU</code>-a i internih magistrala koje ih međusobno povezuju koji je zadužen za transformisanje podataka.
</p></li>

<li><p>
Nacrtati uopštenu shemu putanje podataka sa tri interne magistrale. Primer izvršavanja operacije.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div></li>

<li><p>
Nacrtati uopštenu shemu putanje podataka sa dve interne magistrale. Primer izvršavanja operacije.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div></li>

<li><p>
Nacrtati uopštenu shemu putanje podataka sa jednom internom magistralom. Primer izvršavanja operacije.
</p>

<div class="warning">
<p>
Fali slika ili nešto slično
</p>

</div></li>

<li><p>
Šta je kontrolna jedinica (<code>CU</code>)? Šta je ulaz, a šta izlaz kontrolne jedinice?
</p>

<p>
Kontrolna jedinica je komponenta procesora koja pomoću kontrolnih signala govori <i>datapath</i>-u šta da uradi sa podacima
</p>

<p>
Uloga <code>CU</code> je:
</p>
<ul class="org-ul">
<li>koordinacija podataka iz, u i među procesorskim podjedinicama</li>
<li>interpretiranje instrukcija</li>
<li>kontrola toka podataka u procesoru</li>
<li>generisanje kontrolnih signala na osnovu instrukcija</li>
</ul>

<p>
Ulazu u <code>CU</code> se obavlja prihvatanjem podataka iz prihvatnog registra u dekoder, dok je izlaz od <code>CU</code> zapravo izlaz iz dekodera koji je spojen sa ulazom <code>ALU</code>-a.
</p></li>

<li><p>
Opisati osnovne faze pri izvršavanju instrukcija procesora.
</p>

<p>
Program čini skup instrukcija koje su smeštene u memoriji. Procesor čita redom instrukcije iz memorije, zatim ih izvršava pa prihvata narednu. Proces se ponavlja sve dok je računar upaljen. Ovaj ciklus je poznat kao <b>pribavi-dekodiraj-izvrši</b> (<i>fetch-decode-execute</i>).
</p></li>

<li>Objasniti fazu dohvatanja instrukcije

<ol class="org-ol">
<li>Adresa zapisana u <code>PC</code> se kopira u <code>MAR</code>, nakon čega se <code>PC</code> inkrementira.</li>
<li>Kopira se vrednost iz adrese koja je sačuvana u <code>MAR</code> i smešta se u <code>MDR</code></li>
<li><p>
Eventualno, vrednost iz <code>MDR</code> se kopira u <code>IR</code> nakon čega je faza dohvatanja gotova
</p>

<p>
Pseudo-asembler kod
</p>
<div class="org-src-container">
<pre class="src src-asm"><span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">mar</span>, pc
<span style="color: #42c6ff; font-weight: bold;">inc</span> <span style="color: #ff2afc; font-weight: bold;">pc</span>
<span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">mdr</span>, [mar]
<span style="color: #42c6ff; font-weight: bold;">mov</span> <span style="color: #ff2afc; font-weight: bold;">ir</span>, mdr
</pre>
</div></li>
</ol></li>

<li>Objasniti fazu dekodiranja instrukcije

<ol class="org-ol">
<li>Kodirana instrukcija u <code>IR</code> se dekodira</li>
<li>Zajedno sa upravljačkim signalima, dekodirana instrukcija se šalje dalje na <code>ALU</code> za obradu</li>
</ol></li>

<li>Objasniti fazu izvršavanja instrukcije

<ol class="org-ol">
<li>Na ulaze se dovode operandi, dok se na upravljačke linije dovodi kod operacije</li>
<li>Kao izlaz dobijamo obrađene podatke</li>
</ol></li>

<li>Na koje načine se može realizovati kontrolna jedinica? Poređenje.

<ol class="org-ol">
<li>Hardverski
<ul class="org-ul">
<li>implementira se kroz upotrebu sekvencijalnih logičkih jedinica, zbog čega se dobija komplikovanija struktura sa povećanjem instrukcija</li>
<li>koriste se u <code>RISC</code> arhiterkturi</li>
<li>rade velikom brzinom, ali broj instrukcija koje mogu da implementiraju je ograničen</li>
<li>skuplja izrada</li>
</ul></li>
<li>Mikroprogramski
<ul class="org-ul">
<li>jednostavnija struktura</li>
<li>koriste se u <code>CISC</code> arhitekturi</li>
<li>rade sporije u odnosu na hardverski zbog dodatnog sloja apstrakcije u vidu mikroinstrukcija, ali je lakše izmeniti same instrukcije</li>
<li>jeftinija izrada</li>
</ul></li>
</ol></li>

<li>Objasniti tvrdo ožičenu (hardversku) implementaciju <code>CU</code>

<ul class="org-ul">
<li>implementira se kroz upotrebu sekvencijalnih logičkih jedinica, zbog čega se dobija komplikovanija struktura sa povećanjem instrukcija</li>
<li>koriste se u <code>RISC</code> arhiterkturi</li>
<li>rade velikom brzinom, ali broj instrukcija koje mogu da implementiraju je ograničen</li>
<li>skuplja izrada</li>
<li>danas se retko koriste</li>
</ul></li>

<li><p>
Objasniti mikroprogramsku (softversku) implementaciju <code>CU</code>
</p>

<ul class="org-ul">
<li>jednostavnija struktura</li>
<li>koriste se u <code>CISC</code> arhitekturi</li>
<li>rade sporije u odnosu na hardverski zbog dodatnog sloja apstrakcije između hardvera i mašinskih instrukcija, no lakše je izmeniti instrukcije</li>
<li>jeftinija izrada</li>
<li>danas se praktično uvek koriste</li>
</ul>

<p>
Mikroprogram, koji se sastoji iz mikroinstrukcija sačuvan je u posebnoj <code>ROM</code> ili <code>PLA</code> memoriji <code>CU</code>-a. Izvršavanje mikroinstrukcija generiše skup kontrolnih signala.
</p></li>

<li><p>
Šta je mikroinstrukcija? Struktura mikroinstrukcije
</p>

<p>
Mikroinstrukcija je najmanja celina mikrokoda koji predstavlja programibilni sloj apstrakcije između hardvera i mašinskog koda dostupnog programeru. Struktura mikroinstrukcije može biti <b>horizontalna</b> i <b>vertikalna</b>
</p></li>

<li><p>
Šta je mikroprogram? Objasniti način izvršavanja mikroprograma.
</p>

<p>
Mikroprogram je niz mikroinstrukcija. Ideja mikroprogama je da se mašinske instrukcije mapiraju u ROM ili PLA memoriji u odgovarajuće kontrolne signale.
</p>

<div class="tip">
<p>
TODO
</p>

</div></li>

<li><p>
Objasniti horizontalni format mikroinstrukcija procesora.
</p>

<div class="tip">
<p>
TODO
</p>

</div></li>

<li><p>
Objasniti vertikalni format mikroinstrukcija procesora.
</p>

<div class="tip">
<p>
TODO
</p>

</div></li>
</ol>
</div>
</div>

<div id="outline-container-org49175b8" class="outline-2">
<h2 id="org49175b8"><span class="section-number-2">10</span> Memorija</h2>
<div class="outline-text-2" id="text-10">
<ol class="org-ol">
<li value="145">Karakteristike memorija.

<ul class="org-ul">
<li>kapacitet</li>
<li>adresivost</li>
<li>performanse</li>
<li>trajnost (postojanost) zapisa</li>
<li>mogućnost promene sadržaja</li>
<li>promenljivost zapisa</li>
<li>cena</li>
<li>fizički tip medijuma</li>
</ul></li>

<li>Navesti moguće načine pristupa memoriji

<ul class="org-ul">
<li>sekvencijalni</li>
<li>direktni (neposredni)</li>
<li>proizvoljni (slučajni)</li>
<li>asocijativni</li>
</ul></li>

<li><p>
Objasniti sekvencijalni pristup memoriji
</p>

<p>
Podaci su organizovani u jedinice koje nazivamo <b>slogovi</b> koji su međusobno razdvojeni <b>kontrolnim informacijama</b> (npr. dužina sloga) koje se koriste pri pristupanju određenom slogu.
</p>

<p>
Podaci se upisuju po redosledu unošenja, a čitaju po istom ili obrnutom redosledu.
</p>

<p>
Da bi se pristupilo $i$-tom slogu potrebno je proći kroz svih prethodnih \(i - 1\) slogova, što znači da je ovaj način dosta spor.
</p>

<p>
Primer: magnetna traka
</p></li>

<li><p>
Objasniti direktni (neposredni) pristup memoriji (<i>semi-random</i>)
</p>

<p>
Kod ovog načina pristupa postoji veza između adrese podatka i pozicije njegovog sloga na medijumu. Na osnovu adrese se pristupa lokaciji sloga ili njegovoj okolini. Vreme pristupa je promenljivo i zavisi od pozicije na medijumu.
</p>

<p>
Primer: magnetni disk
</p></li>

<li><p>
Objasniti proizvoljni (slučajni) pristup memoriji (<i>Random Access Memory</i>)
</p>

<p>
Kod ovakvog načina pristupa moguće je u konstantnom vremenu pristupiti bilo kojoj adresibilnoj lokaciji nezavisno od toga gde se fizički nalazi.
</p>

<p>
Primer: glavna memorija (<code>RAM</code>)
</p></li>

<li><p>
Objasniti asocijativni pristup memoriji (<i>Content Adressable Memory</i>)
</p>

<p>
Ovo je podtip proizvoljnog pristupa memoriji koji omogućava pretragu cele memorije na osnovu dela sadržaja (reči) umesto pomoću adrese.
</p>

<p>
Primer: koristi se kod specijalizovanih baza podataka
</p></li>

<li><p>
Šta je kapacitet memorije i u kojim jedinicama se izražava?
</p>

<p>
Kapacitet predstavlja količinu podataka koji se mogu sačuvati u memoriji.
</p>

<p>
Obično se izražava u <code>KiB, MiB, GiB, TiB</code>
</p></li>

<li>Kakva memorija može biti s obzirom na trajnost (postojanost) zapisa? Primeri.

<ul class="org-ul">
<li>Privremena
<ul class="org-ul">
<li>gube zapis s nestankom napajanja</li>
</ul></li>
<li>Stalna
<ul class="org-ul">
<li>čuvaju zapis sve dok ne dođe do namerne promene (ignorišemo fizičko degradiranje materijala itd.)</li>
</ul></li>
</ul></li>

<li>Kakva memorija može biti s obzirom na promenjivost sadržaja? Primeri.

<ul class="org-ul">
<li>promenljive
<ul class="org-ul">
<li>memorija koja se koristi za implementaciju registara i <code>RAM</code></li>
</ul></li>
<li>polu-promenljive
<ul class="org-ul">
<li><code>PROM, EPROM, EEPROM</code></li>
</ul></li>
<li>nepromenljive
<ul class="org-ul">
<li><code>ROM</code></li>
</ul></li>
</ul></li>

<li><p>
Kako se izražava brzina memorije? Koji faktori najviše utiču na brzinu memorije?
</p>

<p>
Izražava se u količini obrađenih podataka po jedinici vremena. Kod RAM memorija se često izražava u \(MHz\).
</p>

<p>
Najviše utiču:
</p>
<ul class="org-ul">
<li>način adresiranja</li>
<li>tehnologija izrade</li>
</ul></li>

<li><p>
Objasniti hijerarhiju memorija
</p>

<div class="tip">
<p>
TODO
</p>

</div>
<p>
Smara, stvarno treba da se ranim ako ne budem znao ovo.
</p></li>

<li><p>
Šta je <code>ROM</code>? Kakve vrste postoje? Gde se koristi?
</p>

<p>
<code>ROM</code> je <i>read-only</i> memorija čiji sadržaj je stalan i ne može se menjati (u klasičnom smislu). Implementira se kao kombinatorno kolo jer vrednosti na izlazu zavise isključivo od vrednosti na ulazu.
</p>

<p>
Najčešće se koristi za smeštanje <i>low-level</i> programa i mikrokoda koji su potrebni za pokretanje računara.
</p>

<p>
Vrste:
</p>
<ul class="org-ul">
<li><code>ROM: Read Only Memory</code></li>
<li><code>PROM: Programmable Read Only Memory</code></li>
<li><code>EPROM: Erasable Programmable Read Only Memory</code></li>
<li><code>EEPROM: Electrically Erasable Programmable Read Only Memory</code></li>
<li><code>Flash</code></li>
</ul></li>

<li><p>
Šta je <code>RAM</code>? Kakve vrste postoje?
</p>

<p>
<code>RAM</code> (<i>Random Access Memory</i>) je memorija sa slučajnim pristupom.
</p>

<p>
Sadržaj memorije se gubi bez napajanja. Moguće je proizvoljan broj puta čitati i pisati iz iste memorije.
</p>

<p>
Vrste:
</p>
<ul class="org-ul">
<li>statički</li>
<li>dinamički</li>
</ul></li>

<li><p>
Šta je statički <code>RAM</code> i koje su njegove osnovne karakteristike? Gde se koristi?
</p>

<p>
<code>SRAM</code> je vrsta <code>RAM</code>-a koja se najčešće koristi za implementaciju keš memorije i registara procesora.
</p>

<p>
Najčešće se implementiraju pomoću D-flip-flopova i nekih drugih kombinatornih kola.
</p>

<p>
Karakteriše ga velika brzina čitanja i pisanja, ali takođe i velika cena izrade, zbog čega se i rezervisano koriste.
</p></li>

<li><p>
Šta je dinamički <code>RAM</code> i koje su njegove osnovne karakteristike? Gde se koristi?
</p>

<p>
<code>DRAM</code> je vrsta <code>RAM</code>-a koja se najčešće koristi za implementaciju glavne memorije u računaru (u &ldquo;narodnom&rdquo; shvatanju <code>RAM</code>).
</p>

<p>
Jedna memorijska jedinica je sačinjena od jednog tranizstora i kondenzatora, što ga čini dosta jeftinim za proizvodnju, kao i kompaktnim za ređanje velikog broja memorijskih ćelija na malom prostoru.
</p>

<p>
Mana <code>DRAM</code>-a je što je potrebno relativno često ažurirati vrednosti jer se vremenom gube iz kondenzatora. Takođe, pri čitanju se vrednost uništava, pa ju je potrebno opet upisati nakon čitanja.
</p></li>

<li><p>
Šta su isprepletane memorije? Objasniti.
</p>

<p>
To je jedna od tehnika koja se koristi za smanjenje kašnjenja prilikom pristupa susednim memorijskim adresama.
</p>

<p>
Ideja je da se memorija izdeli na nekoliko manjih uzastopnih memorijskih jedinica koje nazivamo <b>bankama</b>. Ulazne adrese izdelimo u dva dela \(m\) (viši bitovi) i \(k\) (niži bitovi), tako da \(k\) služi da identifikuje banku, dok \(m\) služi da identifikuje adresu u toj banci. Na taj način možemo paralelno pristupati različitim bankama i da smanjimo vreme koje nam je potrebno za pristupanje memoriji.
</p></li>

<li><p>
Koje vrste preslikavanja memorijskih adresa razlikujemo? Objasniti.
</p>

<p>
Preslikavanje adresa je postupak kojim se fizička memorija mapira u adresnom prostoru računara.
</p>
<div class="tip">
<p>
TODO
</p>

</div>

<p>
Preslikavanje može biti <b>puno</b> i <b>delimično</b>
</p></li>

<li><p>
Objasniti puno preslikavanje memorijskih adresa.
</p>

<p>
Puno preslikavanje memorijskih adresa je <code>1-1</code> preslikavanje (za svaku memorijsku lokaciju postoji najviše jedna adresa koja joj odgovara)
</p>
<div class="tip">
<p>
TODO
</p>

</div></li>

<li><p>
Objasniti delimično preslikavanje memorijskih adresa
</p>

<p>
Puno preslikavanje memorijskih adresa <b>nije</b> <code>1-1</code> preslikavanje (za svaku memorijsku lokaciju postoji najviše jedna adresa koja joj odgovara)
</p>
<div class="tip">
<p>
TODO
</p>

</div></li>

<li><p>
Objasniti poravnanje podataka (memorija).
</p>

<p>
Procesori čitaju podatke u rečima. Ako imamo poravnate podatke to znači da je moguće samo u jednom ciklusu pročitati reč u kojoj se nalazi naš podatak. Kada ne bismo imali poravnate podatke, uštedeli bismo malo na memoriji, ali bismo dosta izgubili na performansama, ne samo zbog većeg broj utrošenih ciklusa za čitanje već i zbog promašaja u kešu.
</p></li>

<li><p>
Navesti osnovne vrste spoljašnjih memorija i navesti njihove karakteristike
</p>

<p>
smara.
</p>

<ul class="org-ul">
<li>magnetna traka</li>
<li>magnetni diskovi (floppy, HDD)</li>
<li>optički diskovi (CD, DVD, BlueRay)</li>
<li>flash drive, SSD</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-org7196f69" class="outline-2">
<h2 id="org7196f69"><span class="section-number-2">11</span> Cache</h2>
<div class="outline-text-2" id="text-11">
<ol class="org-ol">
<li value="166"><p>
Objasniti namenu i osnovni princip rada keša.
</p>

<p>
Keš memorija predstavlja malu količinu brze memorije koja u memorijskoj hijerarhiji stoji između procesorskih registara i glavne memorije i služi da ublaži razliku u brzini između procesora i glavne memorije.
</p>

<p>
Implemenitraju se preko <code>SRAM</code>-a. Funkcionišu tako što unapred dobave podatke ili instrukcije za koje se smatra da postoji velika verovatnoća da će procesoru trebati, zbog čega se u slučajevima kada se pogodi, dosta smanjuje vreme potrebno za neku operaciju.
</p></li>

<li><p>
Objasniti princip lokalnosti. Šta je prostorna a šta vremenska lokalnost? Primeri.
</p>

<p>
Prostorna lokalnost je tendencija naših programa da se podacima i instrukcija pristupa sekvencijalno.
</p>

<p>
Primeri:
</p>
<ul class="org-ul">
<li>u C-u niz predstavlja uzastopni blok memorije, te on zadovoljava princip prostorne lokalnosti</li>
<li>instrukcije najčešće se izvršavaju sekvencijalno, osim ako imamo skokove</li>
</ul>

<p>
Vremenska lokalnost je tendencija naših programa da ponovno koriste iste instrukcije ili podatke.
</p>

<p>
Primer:
</p>
<ul class="org-ul">
<li>ako imamo program koji računa sumu niza, onda se promenljiva koja čuva sumu može staviti u keš zajedno sa instrukcijama u petlji</li>
</ul></li>

<li><p>
Na koji način keš koristi principe prostorne i vremenske lokalnosti?
</p>

<p>
Keš memorije koriste princip prostorne lokalnosti tako što kopiraju celu okolinu nekog podatka/instrukcije iz glavne memorije iako je samo jedan podatak tražen jer se očekuje da će i susedni podaci biti uskoro korišćeni.
</p>

<p>
Princip vremenske lokalnosti ostvaruje se tako što se podaci/instruckije koji su nedavno korišćeni nalaze u kešu, jer je pretpostavka da će uskoro biti ponovo korišćeni.
</p></li>

<li><p>
Objasniti čitanje keša u slučaju pogotka
</p>

<p>
Čitanje keša u slučaju pogotka znači da smo podatak koji smo tražili od glavne memorije našli u kešu. Magistrale za adrese i podatke se blokiraju i razmena podataka se dešava direktno između procesora i keša. Na ovaj način čitanje je dosta brže.
</p></li>

<li><p>
Objasniti čitanje keša u slučaju promašaja
</p>

<p>
Ako se traženi podaci ne nalaze u kešu, onda se čitaju iz memorije i istovremeno upisuju u keš. Magistrale za adrese i podatke su aktivne, što znači da se odvija uobičajeno čitanje iz memorije sa dodatnim upisom u keš što ovaj slučaj čini sporijim nego čitanje iz memorije bez prisutva keša.
</p></li>

<li><p>
Objasniti pisanje keša u slučaju pogotka
</p>

<p>
U slučaju pogodtka postoje dve mogućnosti za pisanje:
</p>
<ul class="org-ul">
<li>samo u kešu</li>
<li>i u kešu i u glavnoj memoriji</li>
</ul></li>

<li><p>
Objasniti pisanje keša u slučaju promašaja
</p>

<p>
U slučaju promašaja podaci se upisuju samo u memoriju zato što ne postoje u kešu.
</p></li>

<li><p>
Šta je preslikavanje adresa keša i koje vrste preslikavanja postoje?
</p>

<p>
blok = uzastopni komad memorije
</p>

<p>
Preslikavanje adrese keša je mapiranje između blokova iz glavne memorije i keš linija.
</p>

<p>
Vrste:
</p>
<ul class="org-ul">
<li>neposredno</li>
<li>set-asocijativno</li>
<li>asocijativno</li>
</ul></li>

<li><p>
Objasniti neposredno preslikavanje adresa keša i dati primer.
</p>

<ul class="org-ul">
<li>Svaki blok se mapira u tačno jednu liniju keša
<ul class="org-ul">
<li>\(M\) - količina glavne memorije</li>
<li>\(m\) - količina keš memorije</li>
<li>\(B\) - veličina jednog bloka memorije</li>
<li>\(C = m / B\) - broj keš linija</li>
<li>\(c_{i} = i \ mod \ C\) - $i$-ti blok memorije se mapira u $c<sub>i</sub>$-tu keš liniju</li>
</ul></li>
<li>Lako je za implementaciju, ali je takođe lako dobiti najgori mogući slučaj</li>
</ul>

<p>
Primer:
</p>
<ul class="org-ul">
<li>\(M = 64\)</li>
<li>\(m = 16\)</li>
<li>\(B = 4\)</li>
<li><p>
\(C = m / B = 4\)
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">i</td>
<td class="org-right">c<sub>i</sub></td>
</tr>

<tr>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-right">3</td>
</tr>

<tr>
<td class="org-right">12</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-right">13</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-right">14</td>
<td class="org-right">2</td>
</tr>

<tr>
<td class="org-right">15</td>
<td class="org-right">3</td>
</tr>
</tbody>
</table></li>
</ul>

<p>
Svaka adresa iz memorije se deli u 3 dela:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">keš tag</td>
<td class="org-left">keš linija id</td>
<td class="org-left">offset</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><i>offset</i>
<ul class="org-ul">
<li>služi da dopuni do veličine bloka zbog poravnanja memorije</li>
<li>zauzima \(b = log_{2}(B)\) bitova</li>
</ul></li>
<li><i>keš linija id</i>
<ul class="org-ul">
<li>moduliramo ovaj uzastopni podniz bitova da bismo dobili na koju liniju keša mapiramo dati blok</li>
<li>zauzima \(c = log_{2}(C)\) bitova</li>
</ul></li>
<li><i>keš tag</i>
<ul class="org-ul">
<li>služi za čuvanje u kešu kako bi keš znao koji blok memorije je u pitanju (pošto se više blokova memorije mogu mapirati u istu keš liniju)</li>
<li>zauzima \(t = B - b - c\) bitova</li>
</ul></li>
</ul>

<p>
U liniji keša čuva se:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">validan bit</td>
<td class="org-left">keš tag</td>
<td class="org-left">keš podatak</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>keš podatak
<ul class="org-ul">
<li>podaci kopirani iz mapiranog bloka memorije</li>
</ul></li>
<li>keš tag
<ul class="org-ul">
<li>pošto se više blokova memorije mogu mapirati u istu keš liniju, koristimo keš tag da ih razlikujemo</li>
</ul></li>
<li><i>validan bit</i>
<ul class="org-ul">
<li>govori da li keš linija sadrži validne podatke (na početku je nego đubre, pa na ovaj način to naznačavamo)</li>
</ul></li>
</ul>
<ul class="org-ul">
<li><p>
Kada želimo da proverimo da li se blok nalazi u kešu potrebno je:
</p>
<ol class="org-ol">
<li>naći &ldquo;id&rdquo; keš linije, odonosno \(c_{i}\)</li>
<li>ako je <i>validan bit</i> jednak \(0\) onda je promašaj</li>
<li>ako se keš tag i trenutni tag razlikuju onda je promašaj</li>
<li>u suprotnom nađen je</li>
</ol>

<p>
Slično važi i za upis, koji je dodatno vezan za polisu upisa.
</p></li>
</ul></li>

<li><p>
Objasniti asocijativno preslikavanje adresa keša i dati primer.
</p>

<ul class="org-ul">
<li>Svaki blok je moguće mapirati u bilo koju keš liniju
<ul class="org-ul">
<li>Ako koristimo <code>FIFO</code> alokaciju, onda se faktički novi blok upisuje u prvu sledeću slobodnu liniju. Kada se popuni keš izbacujemo ih redom kojim smo ih uneli.</li>
<li>\(M\) - količina glavne memorije</li>
<li>\(m\) - količina keš memorije</li>
<li>\(B\) - veličina jednog bloka memorije</li>
<li>\(C = m / B\) - broj keš linija</li>
</ul></li>
</ul>

<p>
Svaka adresa iz memorije se deli u 2 dela:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">keš tag</td>
<td class="org-left">offset</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li><i>offset</i>
<ul class="org-ul">
<li>služi da dopuni do veličine bloka zbog poravnanja memorije</li>
<li>zauzima \(b = log_{2}(B)\) bitova</li>
</ul></li>
<li><i>keš tag</i>
<ul class="org-ul">
<li>služi za čuvanje u kešu kako bi keš znao koji blok memorije je u pitanju (pošto se više blokova memorije mogu mapirati u istu keš liniju)</li>
<li>zauzima \(t = B - b\) bitova</li>
</ul></li>
</ul>

<p>
U liniji keša čuva se:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">validan bit</td>
<td class="org-left">keš tag</td>
<td class="org-left">keš podatak</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>keš podatak
<ul class="org-ul">
<li>podaci kopirani iz mapiranog bloka memorije</li>
</ul></li>
<li>keš tag
<ul class="org-ul">
<li>pošto se više blokova memorije mogu mapirati u istu keš liniju, koristimo keš tag da ih razlikujemo</li>
</ul></li>
<li><i>validan bit</i>
<ul class="org-ul">
<li>govori da li keš linija sadrži validne podatke (na početku je nego đubre, pa na ovaj način to naznačavamo)</li>
</ul></li>
</ul>
<ul class="org-ul">
<li>Kada želimo da proverimo da li se blok nalazi u kešu potrebno je:
<ol class="org-ol">
<li>sve linije koje imaju <i>validan bit</i> jednak \(1\) se uzimaju u obzir</li>
<li>porede se keš tagovi i trenutni tag, ako se ne nađu onda imamo promašaj</li>
<li>u suprotnom nađen je</li>
</ol></li>

<li>Problem nije veća količina memorije odvojena za keš tag, već činjenica da jedan blok može da bude u bilo kojoj keš liniji, zbog čega nam je potreban \(2^{C}\) komparatora što ga čini dosta skupim.</li>
</ul></li>

<li><p>
Objasniti skup-asocijativno preslikavanje adresa keša i dati primer.
</p>

<p>
Skup-asocijativno preslikavanje prestavlja kompromis između <code>neposrednog</code> i <code>asocijativnog</code> preslikavanja i kombinaciju tih ideja.
</p>
<ul class="org-ul">
<li>\(M\) - količina glavne memorije</li>
<li>\(m\) - količina keš memorije</li>
<li>\(B\) - veličina jednog bloka memorije</li>
<li>\(C = m / B\) - broj keš linija</li>
<li>\(S \in \{ 2, 4, 8 \}\) - broj disjunktnih skupova</li>
<li>\(s_{i} = i \ mod \ S\) - $i$-ti blok memorije se mapira u $s<sub>i</sub>$-ti skup keš linija</li>

<li><p>
Izdelimo keš linije u <b>disjunktne skupove</b>, kojima pristupamo metodom sličnom kao kod <code>neposrednog</code> preslikavanja.
</p>
<ul class="org-ul">
<li>Unutar samih skupova unosimo na proizvoljne keš linije kao kod <code>asocijativnog</code> preslikavanja</li>
</ul>

<p>
Svaka adresa iz memorije se deli u 3 dela:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">keš tag</td>
<td class="org-left">skup id</td>
<td class="org-left">offset</td>
</tr>
</tbody>
</table></li>

<li><i>offset</i>
<ul class="org-ul">
<li>služi da dopuni do veličine bloka zbog poravnanja memorije</li>
<li>zauzima \(b = log_{2}(B)\) bitova</li>
</ul></li>
<li><i>skup id</i>
<ul class="org-ul">
<li>moduliramo ovaj uzastopni podniz bitova da bismo dobili na u koji skup mapiramo dati blok</li>
<li>zauzima \(s = log_{2}(S)\) bitova</li>
</ul></li>
<li><i>keš tag</i>
<ul class="org-ul">
<li>služi za čuvanje u kešu kako bi keš znao koji blok memorije je u pitanju (pošto se više blokova memorije mogu mapirati u istu keš liniju)</li>
<li>zauzima \(t = B - b - s\) bitova</li>
</ul></li>
</ul>

<p>
U liniji keša čuva se:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">validan bit</td>
<td class="org-left">keš tag</td>
<td class="org-left">keš podatak</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>keš podatak
<ul class="org-ul">
<li>podaci kopirani iz mapiranog bloka memorije</li>
</ul></li>
<li>keš tag
<ul class="org-ul">
<li>pošto se više blokova memorije mogu mapirati u istu keš liniju, koristimo keš tag da ih razlikujemo</li>
</ul></li>
<li><i>validan bit</i>
<ul class="org-ul">
<li>govori da li keš linija sadrži validne podatke (na početku je nego đubre, pa na ovaj način to naznačavamo)</li>
</ul></li>
</ul>
<ul class="org-ul">
<li>Kada želimo da proverimo da li se blok nalazi u kešu potrebno je:
<ol class="org-ol">
<li>pronaći <i>id</i> skupa u kojem se nalazi blok</li>
<li>sve linije koje imaju <i>validan bit</i> jednak \(1\) se uzimaju u obzir</li>
<li>porede se keš tagovi i trenutni tag, ako se ne nađu onda imamo promašaj</li>
<li>u suprotnom nađen je</li>
</ol></li>
</ul></li>

<li><p>
Šta su i čemu služe politike zamenjivanja keša? Nabrojati ih.
</p>

<ul class="org-ul">
<li>Politika zamenjivanja sa primenjuje radi odabira keš linije čiji sadržaj će biti zamenjen sadržajem novog memorijskog bloka.</li>
<li>Zavisi od primenjenog preslikavanja
<ul class="org-ul">
<li>U slučaju <code>neposrednog</code> preslikavanja <b>nema</b> politike zamene jer nema izbora</li>
</ul></li>
</ul>

<p>
Najčešće se koriste:
</p>
<ul class="org-ul">
<li><code>LRU</code></li>
<li><code>pseudo-LRU</code></li>
<li><code>FIFO</code></li>
<li><code>LFU</code></li>
<li><code>random</code></li>
</ul></li>

<li><p>
Objasniti politiku zamenjivanja najduže nekorišćene linije keša (<code>LRU</code>). Dobre i loše strane.
</p>

<p>
<code>LRU = Least Recently Used</code>
</p>

<p>
Predviđanje zasniva na principu <b>vremenske lokalnosti</b>. Zamenjuje sadržaj one linije keša koja najduže nije bila korišćena.
</p>

<p>
Prednosti:
</p>
<ul class="org-ul">
<li>najbolji rezultati</li>
</ul>
<p>
Mane:
</p>
<ul class="org-ul">
<li>za \(n\) linija potrebno mu je \(n!\) stanja koja je moguće predstaviti kao konačni automat, ali je memorijska složenost prevelika da bi se realizovalo u <code>asocijativnom mapiranju</code></li>
<li>moguće je realizovati za \(2\) ili \(4\) keš linije, zbog čege se i koristi u <code>skup-asocijativnom</code> mapiranju</li>
</ul></li>

<li><p>
Objasniti politiku zamenjivanja pseudo-najduže nekorišćene linije keša (<code>pseudo-LRU</code>). Dobre i loše strane.
</p>

<p>
<code>pseudo-LRU = pseudo Least Recently Used</code>
</p>

<p>
Predstavlja aproksimaciju <code>LRU</code> politike. Keš linije se dele u dve grupe, gde se pomoću jednog bita označava linija keša koja je najskorije korišćena u skupu. Potom se drugoj grupi pristupa koja se dalje deli u podskupove dok ne dođemo do jedne linije keša.
</p>

<p>
Prednosti:
</p>
<ul class="org-ul">
<li>dosta manja memorijska složenost, što se najviše ogleda u situacijama kada imamo više od \(4\) keš linije u jednom skupu</li>
</ul>
<p>
Mane:
</p>
<ul class="org-ul">
<li>smanjena preciznost u odnosu na <code>LRU</code></li>
</ul></li>

<li><p>
Objasniti <code>FIFO</code> politiku zamenjivanja linije keša.
</p>

<p>
Zamenjuje se ona linija keša koja je prva pročitana, tj. ona koja je najduže u kešu.
</p>

<p>
Relativno jednostavna implementacija:
</p>
<ul class="org-ul">
<li>skup linija keša se ponaša kao kružni bafer</li>
<li>za svaki skup je potreban po jedan kružni brojač koji označava koja linija je poslednje popunjena</li>
</ul>

<p>
Retko se koristi
</p></li>

<li><p>
Koje politike pisanja keša postoje i u čemu se razlikuju
</p>

<p>
Kada se podaci menjaju, mora se uzeti u obzir da postoje dve kopije podataka (u kešu i glavnoj memoriji)
</p>

<p>
Dve osnovne politike:
</p>
<ol class="org-ol">
<li>Pisanje sa propuštanjem (<i>write-through</i>) - pisanje se odvija i u kešu i u memoriji</li>
<li>Pisanje sa prepisivanjem (<i>write-back</i>) - samo keš</li>
</ol></li>

<li><p>
Objasniti politiku pisanja keša sa propuštanjem (<i>write-through</i>). Dobre i loše strane
</p>

<p>
Svaki put kada se vrši upis u keš, vrši se i u memoriji.
</p>

<p>
Prednosti:
</p>
<ul class="org-ul">
<li>jednostavna implementacija</li>
</ul>
<p>
Mane:
</p>
<ul class="org-ul">
<li>relativno sporo</li>
</ul></li>

<li><p>
Objasniti politiku pisanja keša sa prepisivanjem (<i>write-back</i>). Dobre i loše strane
</p>

<p>
Ažuriramo isključivo u kešu, dok se pisanje u memoriju odvija pri zameni u kešu. Koristimo <i>update bit</i> koji nam govori da li je keš linija koju treba zameniti bila ažurirana, tj. da li treba ažurirati u glavnoj memoriji. Na ovaj način poboljšavamo performanse zamene linije keša, koja bi bez <i>update bit</i>-a i <i>write-back</i> politikom bila duplo sporija.
</p></li>

<li><p>
Razdvojeni i unifikovani keš. Poređenje.
</p>

<p>
Kod razdvojenog keša postoji poseban keš za podatke i instrukcije, dok je kod unifikovanog sve u jednom.
</p>

<p>
Prednost razdvojenog keša je što omogućava drugačije načine korišćenja principa lokalnosti čime povećava performanse. Takođe olakšava implementaciju jer keš za instrukcije samo čita.
</p>

<p>
Nedostatak razdvojenog keša je u tome što je nemoguće dinamički menjati količinu keša odvojenu za podatke i instrukcije.
</p></li>

<li><p>
Objasniti arhitekture višestepenog keša i način njihovog funkcionisanja.
</p>

<p>
Organizacija keša hijerarhijski u više nivoa može biti:
</p>
<ul class="org-ul">
<li>Inkluzivna - svaki sledeći nivo sadrži podatke iz prethodnog, ali i neke dodatne</li>
<li>Ekskluzivna - ne sadrži iste podatke, već isključivo nove</li>
</ul>

<p>
Prednost inkluzivnog pristupa je u tome što veće keš memorije mogu imati veće linije, dok kod ekskluzivnog sve keš memorije moraju da imaju linije iste veličine
</p>

<p>
Podaci se prvo traže u najbližem kešu, pa ako ih tu nema onda u sledećem itd. dok se ne nađe ili ode do memorije.
</p>
<ul class="org-ul">
<li>kod inkluzivnog se podaci upisuju sve bliže nivoe [CHECK]</li>
<li>kod ekskluzivnog se podaci brišu iz prethodnih nivoa</li>
</ul>

<p>
Danas se najčešće organizuje u 3 nivoa:
</p>
<ul class="org-ul">
<li><code>L1</code> - nalazi se na samom čipu procesora, najbliže samom procesoru</li>
<li><code>L2</code> - uglavnom se nalazi na samom čipu procesora</li>
<li><code>L3</code> - obično je znatno veći i zajednički za sva jezgra na istom procesoru</li>
</ul></li>

<li><p>
Objasniti odnos veličine keša i performansi.
</p>

<p>
Povećanjem keša do određene granice dobijamo bolje performanse, ali se u nekom trenutku taj rast performansi usporava i postaje beznačajan.
</p>

<p>
Ovo se može objasniti time da određenom veličinom keša procenat pogodtka postane blizak \(100%\) nakon čega dalje povećanje nema uticaja
</p></li>

<li><p>
Objasniti odnos veličine linije keša i performansi.
</p>

<p>
Povećanjem linije keša do neke mere se poboljšavaju performanse, ali se u nekom trenutku te performanse počinju kvariti.
</p>

<p>
Za premale linije keša slabo se koristi princip prostorne lokalnosti, dok se za velike smanjuje preciznost.
</p></li>

<li><p>
Objasniti odnos asocijativnosti i performansi.
</p>

<p>
Povećanjem stepena asocijativnosti se povećava procenat pogotka keša. Potpuno asocijativni keš je u tom smislu najbolji, ali je njegova implementacija teška, pa se dizajneri češće odlučuju za <code>skup-asocijativno</code> mapiranje, uz izbor većih skupova kad je to moguće.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orge5ab0a6" class="outline-2">
<h2 id="orge5ab0a6"><span class="section-number-2">12</span> Magistrale</h2>
<div class="outline-text-2" id="text-12">
<ol class="org-ol">
<li value="189"><p>
Šta je magistrala i čemu služi?
</p>

<p>
Magistrala je komunikacioni sistem koji prenosi podatke/instrukcije između komponenti računara ili eksternih uređaja.
</p></li>

<li><p>
Kako se ostvaruje deljenje magistrale? Na koji način se sprečava kolizija signala? Objasniti.
</p>

<div class="tip">
<p>
TODO
</p>

</div>

<p>
Da bismo povezali više uređaja na magistralu, potrebno je sprečiti istovremeno puštanje signala od strane različitih uređaja. Ovo se obično postiže korišćenjem <b>bafera sa tri stanja</b> (<i>tri-state buffer</i>).
</p></li>

<li>Šta je transakcija a šta operacija magistrale? Šta je protokol magistrale?

<ul class="org-ul">
<li>Transakcija predstavlja niz operacija potrebnih za izvršanje jasno definisane akcije.</li>
<li>Operacija predstavlja čitanje/pisanje memorije, čitanje <code>I/O</code> uređaja, &ldquo;rafalno&rdquo; čitanje itd.</li>
<li>Protokol magistrale predstavlja skup pravila kojima se reguliše komunikacija između komponenti</li>
</ul></li>

<li><p>
Šta su serijske, a šta paralelne magistrale? Poređenje.
</p>

<p>
Prema načinu transfera, magistrale je moguće podeliti na:
</p>
<ul class="org-ul">
<li>serijske
<ul class="org-ul">
<li>sastoje se iz jedne linije preko koje se podaci prenose bit po bit</li>
</ul></li>
<li>paralelne
<ul class="org-ul">
<li>sastoje se iz više linija preko kojih se podaci prenose reč po reč</li>
</ul></li>
</ul>

<p>
Naizgled paralelne magistrale deluju kao bolji izbor, ali se ispostavilo da je u većini slučajeva bolje koristiti serijske.
</p>

<p>
Problemi paralelnih magistrala:
</p>
<ul class="org-ul">
<li>zbog različitih dužina i provodljivosti <b>ne stižu</b> svi bitovi <b>u isto vreme</b> što znatno otežava ispravno čitanje</li>
<li>pri velikim frekvencijama dolazi do elektromagnetne indukcije što znači da je moguće da odvojeni signali utiču jedni na druge, a.k.a. <b>interferencija</b></li>
</ul>

<p>
Serijske ne samo što nemaju ove probleme, takođe su jeftinije i jednostavnije za izradu jer je potrebno manje delova. Serijske jesu sporije, ali dozvoljavaju da se poveća frekvencija čime se anulira taj faktor.
</p>

<p>
Zbog toga se danass umesto ranijih paralelnih (<code>PCI, PATA...</code>) koriste serijske magistrale (<code>PCI-Express, SATA, USB</code>). Izuzetak je <b>memorijska magistrala</b> koja povezuje procesor sa glavnom memorijom.
</p></li>

<li><p>
Koja je razlika između multipleksiranih i razdvojenih magistrala? Poređenje.
</p>

<p>
Paralelne magistrale mogu biti:
</p>
<ul class="org-ul">
<li>multipleksirane (<i>multiplexed</i>)
<ul class="org-ul">
<li>iste linije se koriste i za adrese i za podatke tako što se prenose naizmenično u različitim ciklusima</li>
<li><code>PCI</code> magistrala je primer multipleksirane paralelne magistrale</li>
</ul></li>
<li>razdvojene (<i>dedicated</i>)
<ul class="org-ul">
<li>odvojene linije se koriste za adrese, podatke i kontrolne signale (tzv. <i>magistrala podataka, adresna magistrala, kontrolna magistrala</i>)</li>
<li>Memorijska magistrala je primer odvojene paralelne magistrale</li>
</ul></li>
</ul>

<p>
Prednosti multipleksiranih magistrala u odnosu na odvojene je u jeftinijoj implementaciji, a mana je u manjoj brzini prenosa (jer je potrebno više ciklusa za obavljanje transakcije)
</p></li>

<li><p>
Šta je širina magistrale?
</p>

<p>
Širina magistrale određuje veličinu podataka koji se prenose magistralom. Osnovna motivacija za proširivanje je podizanje propustnosti (<i>throughput</i>) a time i performansi. Sužavanje se radi u slučajevima da nam je potrebno da smanjimo složenost, samim tim i cenu.
</p></li>

<li><p>
Objasniti i predstaviti vremenskim dijagramom izvršavanje operacije čitanja u slučaju sinhrone magistrale.
</p>

<div class="tip">
<p>
TODO
</p>

</div></li>

<li><p>
Objasniti i predsaviti vremenskim dijagramom izvršavanje operacije pisanja u slučaju sinhrone magistrale.
</p>

<div class="tip">
<p>
TODO
</p>

</div></li>

<li><p>
Šta je stanje čekanja? Kada se i kako upotrebljava? Objasniti operaciju čitanja sa stanjem čekanja.
</p>

<p>
Imajući u vidu da je procesor često dosta brži od memorije, potrebno je na neki način mu reći da sačeka. Za to se koristi stanje čekanja i kontroni signal <i>ready</i>.
</p>

<ol class="org-ol">
<li>procesor želi da pročita određenu adresu u memoriji, stoga tu adresu postavlja na <b>adresnu magistralu</b>.</li>

<li>pošto je procesor brži od memorije, kontrolni signal <i>ready</i> se postavlja na \(1\) za koje vreme procesor čeka</li>

<li>kada je <i>ready</i> na \(0\) onda procesor uzima podatke sa magistrale podataka</li>
</ol></li>

<li><p>
Šta je &ldquo;prenošenje blokova podataka&rdquo;? Kada se i za šta upotrebljava?
</p>

<p>
Prenošenje blokova podrazumeva da se jednom <b>složenom operacijom</b> prenosi više uzastopnih reči jer se ispostavilo da je efikasnije pri istoj transakciji pročitati više reči nego u više uzastopnih operacija pojedinačno.
</p>

<p>
Koristi se često za popunjavanje keš memorije.
</p></li>

<li><p>
Šta je &ldquo;<i>read-modify-write</i>&rdquo; transakcija i za šta se upotrebljava?
</p>

<p>
Ova transakcija je pogodna za realizaciju ekskluzivnog pristupa <b>zajedničkim podacima/kodu</b> (a.k.a. <i>critical section</i>) kod multiprocesorskih sistema.
</p>

<p>
Predstavlja <b>atomičku</b> operaciju što znači da tokom njenog trajanja nije moguće da se izvrši bilo koja druga operacija nad istom magistralom.
</p></li>

<li><p>
Kako se sinhronizuje rad na asinhronoj magistrali? Objasniti signale i tok aktivnosti (četvorofazno rukovanje)
</p>

<p>
Sinhronizuje se pomoću protokola za eksplicitnu sinhronizaciju kao što je <b>četvorofazno rukovanje</b>.
</p>

<p>
Pošto asinhrone magistrale nemaju zajednički časovnik, uređaji reaguju odmah na pristigle signale.
Kod četvorofaznog rukovanja uvode se dva kontrolna signala <code>MSYN</code> (<i>master synchronization</i>) i <code>SSYN</code> (<i>slave synchronization</i>).
</p>

<p>
Tok aktivnosti:
</p>
<ol class="org-ol">
<li><i>master</i> postavilja sve podatke na magistralu i &ldquo;pali&rdquo; <code>MSYN</code> signal kako bi <i>slave</i>-u stavio do znanja da započinje transakciju</li>

<li><i>slave</i> obavlja transakciju i &ldquo;pali&rdquo; <code>SSYN</code> signal kako bi javio <i>master</i>-u da je završena transakcija</li>

<li><i>master</i> &ldquo;gasi&rdquo; <code>MSYN</code></li>

<li><i>slave</i> &ldquo;gasi&rdquo; <code>SSYN</code></li>
</ol></li>

<li><p>
Prednosti i mane asinhronih magistrala u odnosu na sinhrone.
</p>

<p>
Prednosti:
</p>
<ul class="org-ul">
<li>Brži transfer jer se brzina može prilagoditi brzini uređaja sa kojim komunicira</li>
</ul>
<p>
Mane:
</p>
<ul class="org-ul">
<li>Teža implementacija u odnosu na sinhrone</li>
</ul></li>

<li><p>
Šta je arbitraža magistrale? Objasniti razliku između centralizovane i distribuirane arbitraže.
</p>

<p>
Postojanje više <i>master</i>-a (npr. <code>CPU</code> i <code>DMA</code> kontroler) za jednu magistralu se rešava pomoću arbitraže magistrale.
</p>

<p>
Uloga arbitrže magistrale je da na osnovu <b>politike dodeljivanja</b> i <b>politike oslobađanja</b> odredi kom <i>master</i>-u će dodeliti upravljanje nad magistralom.
</p>

<p>
Kod centralizovanih arbitraža jedan centralni arbitar dobija zahteve od svih <i>master</i>-a i određuje kome dodeljuje magistralu.
Kod distribuiranih arbitraža hardver je distribuiran među <i>master</i>-ima koji međusobno komuniciraju i određuju kome ide magistrala.
</p></li>

<li>Nabrojati i ukratko objasniti politike dodeljivanja magistrale.

<ul class="org-ul">
<li>Politike fiksnih prioriteta
<ul class="org-ul">
<li>svaki master ima fiksiran prioritet i na osnovu toga se i određuje ko će dobiti magistralu</li>
</ul></li>

<li>Politike rotirajućih prioriteta
<ul class="org-ul">
<li>prioritet nije fiksiran i može se na različite načine implementirati kao:
<ul class="org-ul">
<li>funkcija vremena čekanja za dodelu magistrale</li>
<li>kružna politika odnosno onaj koji je poslednji dobio pristup magistrali dobija najniži prioritet</li>
</ul></li>
</ul></li>

<li>Hibridna politika
<ul class="org-ul">
<li>kombinacija prethodne dve politike</li>
</ul></li>
</ul></li>

<li>Navesti i ukratko objasniti politike oslobađanja magistrale.

<ul class="org-ul">
<li>Politika bez preuzimanja
<ul class="org-ul">
<li>oslobađa se magistrala tek kada trenutni <i>master</i> dozvoli
<ul class="org-ul">
<li>jedna varijanta je da uređaj oslobodi čim završi transakciju</li>
<li>druga varijanta je da uređaj oslobodi kad završi transakciju i drugi <i>master</i> je zahteva</li>
</ul></li>
</ul></li>
<li>Politika sa preuzimanjem
<ul class="org-ul">
<li>magistralu je moguće osloboditi u slučaju da je zahteva <i>master</i> višeg prioriteta iako se trenutna transakcija možda nije obavila do kraja</li>
</ul></li>
</ul></li>

<li><p>
Objasniti detaljno mehanizam ulančavanja kod centralizovane arbitraže.
</p>

<p>
Signal za zahtev se formira kao disjunkcija zahteva pojedinačnih <i>master</i>-a na zajedničkoj magistrali.
</p>

<p>
Signal za dodelu se prosleđuje redom od jednog do drugog <i>master</i>-a. Ako neku uređaj nije tražio pristup magistrali onda on prosleđuje sledećem sve dok ne dođe do prvog po prioritetu koji je zatražio pristup magistrali.
</p>

<p>
Veoma je jednostavan za implementaciju, ali mu je mana što omogućava samo fiksni prioritet politike dodele.
</p></li>

<li>Objasniti detaljno mehanizam nezavisnih zahteva kod centralizovane arbitraže.</li>
<li>Električne karakteristike serijskih magistrala</li>
<li>Navesti najčešće načine kodiranja bitova kod serijskog prenosa</li>
<li>Koja je osnovna prednost, a koja mana <code>NRZ</code> kodiranja u odnosu na <code>RZ</code> kodiranje?</li>
<li>Objasniti <code>NRZI</code> kodiranje.</li>
<li>Ukratko objasniti <code>8b/10b</code> kodiranje? Koji je razlog za korišćenje ovog načina kodiranja?</li>
<li>Navesti najčešće korišćene paralelne magistrale i njihove najvažnije karakteristike</li>
<li>Navesti najčešće korišćene serijske magistrale i njihove najvažnije karakteristike</li>
</ol>
</div>
</div>

<div id="outline-container-orgf9eb8cc" class="outline-2">
<h2 id="orgf9eb8cc"><span class="section-number-2">13</span> Sistem prekida</h2>
<div class="outline-text-2" id="text-13">
<ol class="org-ol">
<li value="214"><p>
Šta je sistem prekida i koja mu je uloga?
</p>

<p>
Sistem prekida je mehanizam izmene kontrole toka programa.
</p>

<p>
Osnovna uloga mu je da omogući procesoru da reaguje na događaje koji zahtevaju hitnu obradu koji mogu ali <b>ne moraju</b> biti unapred programirani da se dese.
</p>

<p>
Primeri:
</p>
<ul class="org-ul">
<li>pritiskanje tastera na tastaturi (hardverski)</li>
<li>čitanje/pisanje u fajl (softverski)</li>
<li>deljenje sa 0 (izuzetak)</li>
</ul></li>

<li>Navesti i ukratko objasniti vrste prekida

<ul class="org-ul">
<li>Hardverski a.k.a. <b>asinhroni</b>
<ul class="org-ul">
<li>generišu ih hardverski uređaji koji su povezani sa procesorom</li>
<li>dele se na:
<ul class="org-ul">
<li>maskirajuće</li>
<li>nemaskirajuće</li>
</ul></li>
</ul></li>
<li>Softverski a.k.a. <b>sinhroni</b>
<ul class="org-ul">
<li>izazivaju ih posebne instrukcije u procesoru
<ul class="org-ul">
<li>kod <code>Intel Pentium</code> procesora je to <code>int &lt;interrupt_code&gt;</code></li>
</ul></li>
</ul></li>
<li>Izuzeci (<i>Exceptions</i>)
<ul class="org-ul">
<li>faktički predstavljaju softverske prekide koji se koriste kada dođe do <b>greške</b> u samim instrukcijama (npr. deljenje sa 0, overflow itd.)</li>
</ul></li>
</ul></li>

<li><p>
Objasniti hardverske prekide. Šta su maskirajući, a šta nemaskirajući prekidi?
</p>

<p>
Hardverski prekidi su generisani od strane hardverskih uređaja, najčešće zbog I/O (input/output) tako što procesor ima jedan ili više priključaka na koje se može dovesti signal kojim se izaziva prekid.
</p>

<p>
Zovu se i asinhroni prekidi, jer se mogu dogoditi u bilo kom trenutku (nisu programirani odnosno planirani)
</p>

<ul class="org-ul">
<li>Maskirajući (<i>maskable</i>): procesor ima mogućnost da privremeno ignoriše prekide pa da se pozabavi njima kasnije</li>
<li>Nemaskirajući (<i>non-maskable</i>): procesor mora odmah da reaguje na njih</li>
</ul></li>

<li><p>
Objasniti softverske prekide. Koja je tipična uloga softverskih prekida?
</p>

<p>
Softverske prekide izazivaju posebne instrukcije. Kod <code>Intel Pentium</code> procesora je to <code>int &lt;interrupt_code&gt;</code>, gde je <code>&lt;interrupt_code&gt;</code> \(\in [0, 255]\)
</p>

<p>
Zovu se i sinhroni prekidi, jer se mogu dogoditi u unapred određenom trenutku.
</p>

<p>
Tipično se koriste za dobijanje ulaza od korisnika ili za ispisivanje na ekran itd.
</p></li>

<li><p>
Šta su izuzeci (u kontekstu sistema prekida) i čemu služe?
</p>

<p>
Izuzeci su prekidi koji funkcionišu jako slično kao softverski prekidi, s tim što nastaju kao posledica <b>grešaka</b> u izvršavanju instrukcija.
</p>

<p>
Služe da prekinu nevalidno izvršavanje programa.
</p>

<p>
Primeri:
</p>
<ul class="org-ul">
<li>deljenje sa 0</li>
<li>overflow / underflow</li>
</ul></li>

<li><p>
Šta je vektor prekida? Šta je deskriptor prekida? Gde se nalazi tabela deskriptora prekida?
</p>

<p>
Vektorski prekidi predstavljaju metod pozivanja <i>handler</i>-a prekida.
</p>

<p>
Svakom prekidu se dodeljuje broj \(c \in [0, 255]\) koji se koristi za indeksiranje u tabeli deskriptora prekida.
</p>

<p>
Vektor prekida (<b>a.k.a.</b> deskriptor prekida) predstavlja jedno polje u tabeli deskriptora prekida u kojoj se za svaki prekid čuva <b>adresa</b> njegovog <i>handler</i>-a.
</p>

<p>
Tabela deskriptora prekida (TDP) može da se nalazi bilo gde u memoriji. Lokacija je sačuvana pomoću 48-bitnog <b>registra za TDP</b> koji čuva 32-bitnu adresu TDP-a i 16-bitnu vrednost veličine TDP-a.
</p></li>

<li><p>
Objasniti detaljno način pozivanja rukovaoca (<i>handler</i>) prekidom u slučaju vektorskih prekida.
</p>

<p>
Tabela deskriptora prekida = TDP
</p>

<ol class="org-ol">
<li>Svakom prekidu se dodeljuje broj \(c \in [0, 255]\) koji se koristi za indeksiranje u TDP.</li>

<li>Imajući u vidu da se u TDP čuvaju <b>64-bitne adrese</b> <i>handler</i>-a za svaki prekid, potrebno je skalirati \(c\) sa \(8\) odnosno \(i = c * 8\) pomoću čega dobijamo pravi indeks za TDP</li>

<li>Uzimamo adresu \(a = TDP[i]\) i kontrolu predajemo <i>handler-u</i> na toj adresi</li>

<li>Nakon što je <i>handler</i> završio svoje vraćamo kontrolu programu koji se izvršavao pre prekida</li>
</ol></li>

<li><p>
Objasniti komponente i rad kontrolora prekida <code>PIC 8259</code> (/Programmable Interrupt Controller)
</p>

<p>
<code>PIC</code> služi da upravlja sa više uređaja koji mogu slati signale prekida.
</p>

<p>
Moguće je povezati 8 uređaja koji se povezuju pomoću magistrala <code>IRQ0</code> &#x2026; <code>IRQ7</code> kojima <code>BIOS</code> dodeljuje prioritet
</p>

<p>
Kada neki uređaj želi da izazove prekid, on kontroleru putem svoje ulazne magistrale šalje signal nakon čega na osnovu prioriteta kontroler određuje da li će uslužiti taj uređaj.
</p>

<p>
Komunicira sa procesorom putem donjih 8 bitova data magistrale putem kojih i šalje indeks za vektor prekida.
</p></li>
</ol>
</div>
</div>
<div id="outline-container-orge6efa74" class="outline-2">
<h2 id="orge6efa74"><span class="section-number-2">14</span> I/O</h2>
<div class="outline-text-2" id="text-14">
<ol class="org-ol">
<li value="222"><p>
Šta su ulazno/izlazni uređaji?
</p>

<p>
Ulazno/izlazni uređaji predstavljaju sredstvo pomoću kojeg računar komunicira sa spoljašnjim svetom odnosno sa čovekom i drugim uređajima.
</p></li>

<li><p>
Šta su ulazno/izlazni kontroleri i koja je njihova uloga?
</p>

<p>
<code>I/O</code> = Ulazno/izlazni
</p>

<p>
<code>I/O</code> kontroler je komponenta pomoću koje procesor komunicira sa I/O uređajem. Kontroler se sa jedne strane povezuje sa <code>I/O</code> uređajem, dok se sa druge povezuje na sistemsku magistralu pomoću koje komunicira sa procesorom.
</p>

<p>
Vrši <i>low-level</i> komunikaciju sa <code>I/O</code> uređajem, dok procesoru daje unifikovan interfejs za komunikaciju sa <code>I/O</code> uređajem.
</p></li>

<li><p>
Šta podrazumeva upotreba <code>I/O</code> uređaja putem memorijskog mapiranja?
</p>

<p>
<code>I/O port</code> = <b>adresa</b> internih registara <code>I/O</code> kontrolera (najčešće <b>status</b>, <b>data</b>, <b>command</b> registri)
</p>

<p>
Podrazumeva mapiranje <code>I/O</code> portova i adresa u glavnoj memoriji u <b>isti adresni prostor</b>.
</p>

<p>
Posledica toga je da procesor pristupa pomoću <b>istih instrukcija</b> nasumičnoj adresi u glavnoj memoriji i internom registru <code>I/O</code> kontrolera.
</p>

<p>
<code>I/O</code> kontroleri kada primete na adresnoj magistrali <code>I/O</code> port, šalju odgovarajuće podatke na data magistralu.
</p></li>

<li><p>
Šta podrazumeva upotreba <code>I/O</code> uređaja putem izolovanog ulaza i izlaza?
</p>

<p>
<code>I/O port</code> = <b>adresa</b> internih registara <code>I/O</code> kontrolera (najčešće <b>status</b>, <b>data</b>, <b>command</b> registri)
</p>

<p>
Podrazumeva mapiranje <code>I/O</code> portova i adresa u glavnoj memoriji u <b>različite adresne prostore</b>.
</p>

<p>
Posledica toga je da procesor pristupa pomoću <b>različitih instrukcija</b> nasumičnoj adresi u glavnoj memoriji i internom registru <code>I/O</code> kontrolera.
</p>

<p>
Kod <code>Intel Pentium</code> procesora koriste se instrukcije <code>in</code> i <code>out</code> za pristup <code>I/O</code> portovima
</p></li>

<li><p>
Objasniti tehniku programiranog <code>I/O</code>
</p>

<p>
<i>polling</i> = periodično proveravanje vrednosti
</p>

<p>
Funkcioniše tako što procesor <i>poll</i>-uje <b>status registar</b> <code>I/O</code> kontrolera i time proverava da li je <code>I/O</code> uređaj slobodan. Ako jeste u <b>data registar</b> upisuje podatke koje želi da obradi, nakon čega <b>command registar</b> upisuje odgovarajući kod u zavisnosti od čitanja ili pisanja. U suprotnom procesor zapitkuje <code>I/O kontroler</code> sve dok ne bude slobodan (&ldquo;beskonačna petlja&rdquo;).
</p>

<p>
Analogija: Šef da zadatak radniku, pa ga na svakih 5min pita da li je uradio, gubeći vreme na taj način
</p>

<p>
Mana ovog pristupa je to što je procesor sve vreme u upotrebi.
</p></li>

<li><p>
Objasniti tehniku <code>I/O</code> vođenog prekidima
</p>

<p>
Ideja je slična programiranom <code>I/O</code>, s tim što procesor delegira posao drugom kontroleru (npr. <code>DMAC</code>) koji je zadužen za transfer, dok procesor obavlja druge instrukcije. Kada se transfer završi, kontroler obaveštava procesor pomoću signala prekida.
</p>

<p>
Analogija: Šef da zadatak radniku i kaže mu da ga obavesti kada završi, dok će on u međuvremenu završavati ostale poslove
</p></li>

<li><p>
Objasniti direktan pristup memoriji (<code>DMA</code>). Kontroler <code>DMA</code>. Koraci pri realizaciji <code>DMA</code> pristupa
</p>

<p>
<code>DMAC</code> = <code>DMA</code> kontroler
</p>

<p>
<code>DMA</code> predstavlja rešenje za preopterećenje procesora kod <code>programiranog I/O</code> (&ldquo;beskonačnu petlju&rdquo;) tako što se posao organizovanja transfera delegira na <code>DMAC</code>
</p>

<ol class="org-ol">
<li>Procesor šalje <code>DMAC</code>-u \((id, adr, size, op)\)
<ul class="org-ul">
<li>\(id\) - broj koji identifikuje <code>I/O</code> uređaj</li>
<li>\(adr\) - adresa gde treba čitati/pisati u memoriji</li>
<li>\(size\) - broj bajtova</li>
<li>\(op\) - definiše da li je u pitanju čitanje ili pisanje</li>
</ul></li>
<li><code>DMAC</code> zahteva pristup sistemskoj magistrali</li>
<li>Nakon što <b>arbitar</b> odobri pristup
<ul class="org-ul">
<li>na adresnu magistralu se postavlja \(adr\)</li>
<li>šalju se kontrolni signali u \(id\), nakon čega se obezbeđuje da se podatak prenese preko data magistrale</li>
</ul></li>
<li>Šalje se signal za prekid procesoru, kako bi se obavestio da je transfer završen</li>
</ol></li>
</ol>
</div>
</div>

<div id="outline-container-org2531953" class="outline-2">
<h2 id="org2531953"><span class="section-number-2">15</span> Virtuelna memorija</h2>
<div class="outline-text-2" id="text-15">
<ol class="org-ol">
<li value="229"><p>
Šta je virtuelna memorija i zbog čega se koristi?
</p>

<p>
Virtuelna memorija predstavlja tehniku upravljanja memorijom koja omogućava da svaki program ima <i>idealizovan</i> pogled na memoriju.
</p>

<p>
Idealizovan pogled:
</p>
<ul class="org-ul">
<li>programu memorija izgleda <b>nefragmentisano</b> i kao da je <b>sam</b> u memoriji, zbog čega individualni programi ne moraju da brinu o upravljanju memorije</li>
<li>svaki program ima <b>sopstveni virtuelni adresni prostor</b> koji je veći nego količina fizički dostupne memorije pomoću tehnike <i>paging</i>-a (delovi memorije koji se najređe koriste se stavljaju na <i>storage</i> odnosno <code>SSD/HDD</code> i &ldquo;uvoze&rdquo; u <code>RAM</code> po potrebi)</li>
</ul>

<p>
U instrukcijama se koriste virtuelne adrese koje <code>MMU</code> (<i>Memory Management Unit</i>) u procesoru prevodi u fizičke adrese
</p>

<p>
Koristi se jer apstrakuje ručno upravljanje memorije (programer ne mora da razmišlja da li ima dovoljno memorije, gde će se ona nalaziti i da li drugi programi mogu da joj pristupe / da je korumpiraju)
</p></li>

<li><p>
Objasniti koncept stranica virtuelne memorije. Šta su stranice, a šta okvir stranica?
</p>

<ul class="org-ul">
<li>Stranice (<i>pages</i>) predstavljaju <b>virtuelne</b> memorijske blokove fiksne veličine.</li>
<li>Okviri (<i>frames</i>) predstavljaju <b>fizičke</b> memorijske blokove fiksne veličine.</li>
</ul>

<p>
Stranice predstavljaju najmanju jedinicu podataka za upravljanje virtuelnom memorijom. Čuvamo ih i u glavnoj memoriji (<code>RAM</code>) i pomoćnoj memoriji (npr. <code>SSD</code>).
</p>

<p>
Mapiranje <i>page</i>-ova u <i>frame</i>-ove i njihova automatska zamena iz pomoćne u glavnu memoriju (i obrnuto) od strane OS se naziva <i>paging</i> (na srpskom straničenje, fuj).
</p>

<p>
<i>Paging</i> nam omogućava da imamo naizgled neograničenu memoriju (iz perspektive programa).
</p></li>

<li><p>
Objasniti preslikavanje adresa virtuelne memorije. Primer.
</p>

<p>
Virtuelnu memoriju možemo posmatrati kao preslikavanje većeg virtuelnog adresnog prostora u manji fizički adresni prostor.
</p>

<p>
Koristimo <code>MMU</code> (<i>Memory Management Unit</i>) za preslikavanje virtuelnih u fizičke adrese. <code>MMU</code> se implementira pomoću <b>tablice stranica</b> (<i>page table</i>) koja koristi softverski implementirano asocijativno mapiranje, što znači da svaku <b>stranicu</b> možemo mapirati u svaki <b>okvir</b>.
</p>

<p>
Primer: \(32bit \rightarrow 24bit\)
</p>

<p>
Slikamo iz 32-bitnog u 24-bitni adresni prostor. Neka je veličina stranice \(4KiB = 2^{2} \cdot 2^{10}B = 2^{12}B\)
</p>

<ul class="org-ul">
<li><p>
Struktura virtuelne adrese:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">broj stranice (20bit)</td>
<td class="org-left">pomeraj (12bit)</td>
</tr>
</tbody>
</table></li>

<li><p>
Struktura fizičke adrese:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">broj okvira (12bit)</td>
<td class="org-left">pomeraj (12bit)</td>
</tr>
</tbody>
</table></li>

<li><b>Pomerajem</b> određujemo <b>indeks</b> u samoj stranici ili okviru. On se pri preslikavanju ne menja</li>
<li>Gornjih 20 bitova virtuelne adrese se preslikava u gornjih 12 bitova fizičke adrese pomoću <code>MMU</code>.</li>
</ul></li>

<li><p>
Preslikavanje adresa na više nivoa. Zbog čega se koristi? Primer.
</p>

<p>
Kada imamo veliki virtuelni adresni prostor imaćemo i veliki broj <b>stranica</b> u <b>tablici</b> što zauzima dosta <b>uzastopnog</b> prostora u memoriji. Preslikavanje na više nivoa koristimo kako bismo izdelili samu tablicu u nekoliko manjih tablica, čime bismo rešili ranijepomenuti problem.
</p>

<p>
Primer:
</p>
<ul class="org-ul">
<li>Neka naš sistem koristi 40-bitni adresni prostor sa stranicama koje mogu da smeste 4KiB stavki, gde je svaka stavka 4B
<ul class="org-ul">
<li>veličina adresnog prostora: \(A = 40b\)</li>
<li>broj stavki u jednoj stranici: \(P = 4KiB = 2^{12}B\)</li>
<li>veličina jedne stavke u stranici: \(s = 4B\)</li>
<li>broj adresa: \(cnt = 2^{A} = 2^{40}\)</li>
<li>broj stranica: \(p_{1} = \frac{cnt}{P} = 2^{28}\)</li>
</ul></li>
<li>Ukupna memorija koju bi naša tablica zauzimala:
<ul class="org-ul">
<li>\(M_{1} = s * p_{1} = 2^{30} = 1GiB\)</li>
</ul></li>
<li>Pošto je to previše da bismo alocirali <b>uzastopno</b> u memoriji,  izdelimo stranice u manje tablice na koje povežemo tablicu koju nazivamo <b>direktorijum</b>. Pristupamo manjim tablicama pomoću <b>broja tablice</b> (<code>BT</code>) kojim indeksiramo direktorijum.
<ul class="org-ul">
<li>broj stavki u jednoj stranici: \(P = 4KiB = 2^{12}B\) (ostaje isti)</li>
<li>veličina jedne stavke u stranici: \(s = 4B\) (ostaje ista)</li>
<li>broj stranica: \(p_{2} = \frac{p_{1}}{P} = \frac{2^{30}}{2^{12}} = 2^{18}\)</li>
</ul></li>
<li>Memorija koju bi <b>jedna</b> naša tablica drugog nivoa zauzimala (imamo ih \(2^{10}\) komada):
<ul class="org-ul">
<li>\(M_{2} = s * p_{2} = 2^{20} = 1MiB\)</li>
</ul></li>
<li>Nakon što pomoću <code>BT</code> pristupimo direktorijumu da bismo dobili tablicu stranica, koristimo <b>broj stranice</b> (<code>BS</code>) da bismo u tablici stranica pristupilii <b>okviru</b> za stranicu koju smo tražili.
Virtuelna adresa ima oblik:</li>
</ul>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(BT\) (10 bitova)</td>
<td class="org-left">\(BS\) (18 bitova)</td>
<td class="org-left">\(pomeraj\) (12 bitova)</td>
</tr>
</tbody>
</table>

<p>
Prednost je u tome što ne moramo čuvati celu tablicu u memoriji već samo njen direktorijum (tablicu stranica drugog nivoa) i po potrebi možemo učitavati sa diska.
</p>

<p>
Mana je što se smanjuje efikasnost pri prevođenju adresa.
</p></li>

<li><p>
Šta su i kada se koriste politike zamene stranica?
</p>

<p>
Politike zamene predstavljaju algoritme koje koristimo za određivanje koju stranicu bi trebalo sačuvati na pomoćnoj memoriji (npr. <code>SSD</code>) kada nam se glavna memorija (<code>RAM</code>) popuni stranicama a potrebno je da učitamo novu stranicu.
</p></li>

<li>Navesti i ukratko objasniti najčešće politike zamene stranica

<ul class="org-ul">
<li><code>FIFO = First In First Out</code>
<ul class="org-ul">
<li>izbacuje se ona stranica koja je prva ubačena, nevezano da li se koristi često</li>
<li>jednostavno za implementaciju ali neefikasno</li>
</ul></li>
<li><code>Second Chance</code>
<ul class="org-ul">
<li>predstavlja blago unapređenu <code>FIFO</code> politiku</li>
<li>svakoj stranici se pridružuje jedan bit koji govori da li je korišćena od kada u memoriji, i izbacuje se ona stranica koja je najduže a nije nijednom referisana</li>
<li>jednostavno za implementaciju ali neefikasno (efikasnije od <code>FIFO</code>)</li>
</ul></li>
<li><code>NFU = Not Frequently Used</code>
<ul class="org-ul">
<li>brojimo koliko puta je neka stranica korišćena (imamo brojač za svaku), i menjamo onu koja je najmanje puta izbrojana</li>
<li>relativno jednostavno za implementaciju, ali i dalje nedovoljno efikasno</li>
</ul></li>
<li><code>pseudo LRU = pseudo Least Recently Used</code>
<ul class="org-ul">
<li>predviđanje zasniva na principu <b>vremenske lokalnosti</b>. Zamenjuje onu stranicu koja najduže nije bila korišćena.</li>
<li>za svaku stranicu čuvamo masku veličine \(1B\) gde su svi bitovi postavljeni na 1 (\(mask = 0x255\))
<ul class="org-ul">
<li>ako koristimo trenutnu stranicu, masku shiftujemo ulevo, u suprotnom udesno</li>
<li>ako nam je maska jednaka \(0\), to znači da je nismo koristili u 8 ciklusa, dok maska \(mask = 0b00111111\) znači da je skoro korišćena stranica</li>
<li>što nam je veći broj bitova kojim predstavljamo masku to nam je bolja aproksimacija <code>LRU</code>-a</li>
</ul></li>
</ul></li>
</ul></li>

<li><p>
Objasniti značaj veličine stranice virtuelne memorije i navesti primer.
</p>

<ul class="org-ul">
<li>Male &gt; Velike stranice:
<ul class="org-ul">
<li>smanjenje interne fragmentacije odnosno povećanje iskorišćenosti stranica
<ul class="org-ul">
<li>veličina podataka, programa i steka nije ceo broj stranica, pa je prosečno pola stranice neupotrebljeno (ovo se naziva <b>interna fragmentacija</b>)</li>
</ul></li>
<li>bolje pogađanje
<ul class="org-ul">
<li>što je veća stranica, to će pri njenom učitavanju u glavnu memoriju zastupljenost nepotrebnih sadržaja biti veća</li>
</ul></li>
</ul></li>
<li>Velike &gt; Male stranice:
<ul class="org-ul">
<li>manje tablice
<ul class="org-ul">
<li>što su stranice veće, biće ih manje, pa su i tablice manje</li>
</ul></li>
<li>efikasniji pristup disku
<ul class="org-ul">
<li>vreme pristupa disku je mnogo veće nego sam transfer, pa je za manje vreme moguće pročitati manju količinu većih podataka nego veću količinu malih podataka (jer se broj pristupa disku redukuje)
<ul class="org-ul">
<li>Čitanje 100 stranica od 4KiB traje \(100 \cdot (10ms+ \frac{4}{100}ms) = 10.04s\)</li>
<li>Čittanje 25 stranica od 16KiB traje \(25 \cdot (10ms + \frac{16}{100}ms) = 2.54s\)</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>
Primer veličine stranice:
</p>
<ul class="org-ul">
<li>Intel x86: stranice su uobičajeno 4KiB, a podržane su i stranice veličine 2/4MiB</li>
</ul></li>

<li><p>
Šta su tablice, a šta direktorijuma stranica virtuelne memorije? Objasniti.
</p>

<p>
Tablice stranica predstavljaju asocijativnu strukturu (mapu) pomoću koje prevodimo stranice u okvire.
</p>

<p>
Koristimo <b>broj stranice</b> (<code>BS</code>) za indeksni pristup tablici stranica. U tom polju (stavki) između ostalog će nam se nalaziti <b>okvir</b> za stranicu čijim <code>BS</code>-om smo pristupili.
</p>

<p>
Direktorijum stranica predstavlja asocijativnu strukturu (mapu) pomoću koje pristupamo tablici stranica.
</p>

<p>
Umesto da imamo jednu veliku neprekidnu tablicu, izdelimo stranice u manje tablice i na koje povežemo tablicu koju nazivamo <b>direktorijum</b>. Pristupamo manjoj tablici gde nam se tražena stranica nalazi pomoću <b>broja tablice</b> (<code>BT</code>) kojim indeksiramo direktorijum.
</p>

<p>
Možemo imati nekoliko nivoa direktorijuma.
</p>

<p>
Čuvanjem početne adrese master (početnog) direktorijuma u posebnom registru praktično dobijamo \(n\) -arno stablo koje nam služi za prevođenje stranica u okvire.
</p>

<p>
Što nam je veća dubina stabla, to nam je prevođenje neefikasnije.
</p>

<p>
<code>BT</code> i <code>BS</code> &ldquo;izvlačimo&rdquo; kao uzastopne podnizove iz virtuelne adrese. Broj bitova koji je potreban za njih zavisi od veličine stranice i veličine adresnog prostora.
</p>

<p>
Redosled &ldquo;izvlačenja&rdquo; iz virtuelne adrese
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-left">\(BT_{k}\)</td>
<td class="org-left">\(BT_{k - 1}\)</td>
<td class="org-left">&#x2026;</td>
<td class="org-left">\(BT_{0}\)</td>
<td class="org-left">\(BS\)</td>
<td class="org-left">\(pomeraj\)</td>
</tr>
</tbody>
</table>

<p>
Gde je \(k\) dubina stabla.
</p></li>

<li><p>
Šta sadrže stavke u tablici stranica virtuelne memorije? Objasniti.
</p>

<p>
Sadržaj:
</p>
<ul class="org-ul">
<li>broj okvira
<ul class="org-ul">
<li>lokacija date stranice u glavnoj memoriji</li>
<li>vodi se za stranice koje postoje u glavnoj memoriji</li>
</ul></li>
<li>adresa stranice na disku
<ul class="org-ul">
<li>lokacija date stranice na disku</li>
<li>vodi se za sve stranice</li>
</ul></li>
<li><i>valid bit</i>
<ul class="org-ul">
<li>označava da li je stranica u memoriji ili ne</li>
</ul></li>
<li><i>dirty bit</i>
<ul class="org-ul">
<li>označava da li je sadržaj stranice menjan</li>
<li>ako je menjana, stranica se pri uklanjanju iz glavne memorije zapisuje na disku</li>
</ul></li>
<li><i>reference bit</i>
<ul class="org-ul">
<li>koristi se za implementaciju <code>pseudo-LRU</code> algoritma</li>
<li>OS povremeno postavlja sve bitove referisanja na 0</li>
<li>pri pristupanju stranici bit se postavlja na 1</li>
</ul></li>
<li>informacija o vlasniku
<ul class="org-ul">
<li>OS mora da zna kom procesu pripada stranica</li>
</ul></li>
<li>bitovi zaštite
<ul class="org-ul">
<li>označavaju tip pristupa koji vlasnik ostvaruje (<i>read</i>, <i>write</i>, <i>execute</i>)</li>
</ul></li>
</ul></li>

<li><p>
Šta je bafer tablice stranica virtuelne memorije (<code>TLB</code>) i čemu služi?
</p>

<p>
<code>TLB</code> = <i>Translation Lookaside Buffer</i>
</p>

<p>
<code>TLB</code> je asocijativni keš koji čuva poslednje korišćene <b>stavke</b> iz tabele stranica (između ostalog fizičke adrese).
</p>

<p>
Da njega nema, za svako prevođenje bila bi potrebna dva pristupa memoriji, jedan za pronalaženje okvira (koje može biti dosta sporo kada imamo nekoliko slojeva direktorijuma stranica), i drugi za pristupanje samoj vrednosti.
</p>

<p>
Korišćenjem <code>TLB</code> dovoljno često eliminišemo potrebu za pronalaženjem okvira čime znatno poboljšavamo performanse.
</p></li>
</ol>
</div>
</div>

<div id="outline-container-org27e8d91" class="outline-2">
<h2 id="org27e8d91"><span class="section-number-2">16</span> Moderni procesori</h2>
<div class="outline-text-2" id="text-16">
<ol class="org-ol">
<li value="239">Objasniti princip preklapanja instrukcija u modernim procesorima</li>
<li>Koji su osnovni uzroci zaustavljanja &ldquo;pokretne trake&rdquo; kod preklapanja instrukcija u savremenim procesorima? Koje se tehnike koriste za rešavanje ovakvih problema?</li>
<li>Objasniti tehniku izvršavanja van redosleda (<i>out-of-order execution</i>)</li>
<li>Objasniti tehniku predikcije grananja (<i>branch prediction</i>)</li>
<li>Šta su superskalarni procesori?</li>
</ol>
</div>
</div>

<div id="outline-container-orgdab1616" class="outline-2">
<h2 id="orgdab1616"><span class="section-number-2">17</span> Verilog</h2>
<div class="outline-text-2" id="text-17">
<ol class="org-ol">
<li value="244">Koji su osnovni tipovi podataka u jeziku <i>Verilog</i>?</li>
<li>Objasniti razliku između žičanih i registarskih tipova u jeziku <i>Verilog</i></li>
<li>Šta predstavljaju vektorski tipovi, a šta nizovi u jeziku <i>Verilog</i>?</li>
<li>Šta predstavlja vrednost \(z\) a šta vrednost \(x\) u jeziku <i>Verilog</i>?</li>
<li>Na koji način se u jeziku <i>Verilog</i> mogu izdvajati podsignali iz vektorskih signala, a na koji način se jednostavniji signali mogu grupisati u složenije?</li>
<li>Šta su moduli u jeziku <i>Verilog</i>? Kakvi moduli postoje? Na koji način se moduli instanciraju? Primer</li>
<li>Šta su portovi u jeziku <i>Verilog</i>? Koje vrste portova postoje i kako se deklarišu? Primer.</li>
<li>Na koji način se može zadavati kašnjenje pilikom modelovanja na nivou gejtova u jeziku <i>Verilog</i>? Primer.</li>
<li>Objasniti naredbu <i>assign</i> u jeziku <i>Verilog</i>. Zadavanje kašnjenja. Primer.</li>
<li>Koje vrste procesa na nivou modelovanja ponašanja postoje u jeziku <i>Verilog</i>?</li>
<li>Opisati sintaksu i semantiku <i>initial</i> procesa u jeziku <i>Verilog</i>. Primer</li>
<li>Opisati sintaksu i semantiku <i>always</i> procesa u jeziku <i>Verilog</i>. Primer</li>
<li>Na koji način se može kontrolisati izvršavanje <i>always</i> procesa u jeziku <i>Verilog</i>?</li>
<li>Naredbe proceduralne dodele u jeziku <i>Verilog</i>. Blokirajuće i neblokirajuće dodele. Primeri.</li>
<li>Na koji način se može zadavati kašnjenje prilikom izvršavanja naredbi u okviru procesa u jeziku <i>Verilog</i>?</li>
<li>Naredbe grananja u jeziku <i>Verilog</i>. Primeri</li>
<li>Dizajn kombinatornih kola pomoću <i>always</i> procesa u jeziku <i>Verilog</i>. Primeri</li>
<li>Dizajn asinhronih sekvencijalnih kola pomoću <i>always</i> procesa u jeziku <i>Verilog</i>. Primeri</li>
<li>Dizajn sinhronih sekvencijalnih kola pomoću <i>always</i> procesa u jeziku <i>Verilog</i>. Primeri</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Aleksandar Šmigić</p>
<p class="date">Created: 2020-06-23 Tue 21:48</p>
</div>
</body>
</html>
